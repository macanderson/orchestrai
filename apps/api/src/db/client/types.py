# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


from typing_extensions import LiteralString
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List['Serializable'],
    Dict[None, 'Serializable'],
    Dict[bool, 'Serializable'],
    Dict[float, 'Serializable'],
    Dict[int, 'Serializable'],
    Dict[str, 'Serializable'],
]


StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilter'],
        'mode': SortMode,
        'search': str,
    },
    total=False,
)



class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilter'],
    },
    total=False,
)



class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilter'],
    },
    total=False,
)



class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilter'],
    },
    total=False,
)



class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilter'],
    },
    total=False,
)



class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilter'],
    },
    total=False,
)



class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilter'],
    },
    total=False,
)



class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _LicenseTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.LicenseType']]


class _LicenseTypeListFilterHasInput(TypedDict):
    has: 'enums.LicenseType'


class _LicenseTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.LicenseType']


class _LicenseTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.LicenseType']


class _LicenseTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


LicenseTypeListFilter = Union[
    _LicenseTypeListFilterHasInput,
    _LicenseTypeListFilterEqualsInput,
    _LicenseTypeListFilterHasSomeInput,
    _LicenseTypeListFilterIsEmptyInput,
    _LicenseTypeListFilterHasEveryInput,
]


class _LicenseTypeListUpdateSet(TypedDict):
    set: List['enums.LicenseType']


class _LicenseTypeListUpdatePush(TypedDict):
    push: List['enums.LicenseType']


LicenseTypeListUpdate = Union[
    List['enums.LicenseType'],
    _LicenseTypeListUpdateSet,
    _LicenseTypeListUpdatePush,
]

class _UserRoleTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.UserRoleType']]


class _UserRoleTypeListFilterHasInput(TypedDict):
    has: 'enums.UserRoleType'


class _UserRoleTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.UserRoleType']


class _UserRoleTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.UserRoleType']


class _UserRoleTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


UserRoleTypeListFilter = Union[
    _UserRoleTypeListFilterHasInput,
    _UserRoleTypeListFilterEqualsInput,
    _UserRoleTypeListFilterHasSomeInput,
    _UserRoleTypeListFilterIsEmptyInput,
    _UserRoleTypeListFilterHasEveryInput,
]


class _UserRoleTypeListUpdateSet(TypedDict):
    set: List['enums.UserRoleType']


class _UserRoleTypeListUpdatePush(TypedDict):
    push: List['enums.UserRoleType']


UserRoleTypeListUpdate = Union[
    List['enums.UserRoleType'],
    _UserRoleTypeListUpdateSet,
    _UserRoleTypeListUpdatePush,
]

class _CareerLevelListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.CareerLevel']]


class _CareerLevelListFilterHasInput(TypedDict):
    has: 'enums.CareerLevel'


class _CareerLevelListFilterHasEveryInput(TypedDict):
    has_every: List['enums.CareerLevel']


class _CareerLevelListFilterHasSomeInput(TypedDict):
    has_some: List['enums.CareerLevel']


class _CareerLevelListFilterIsEmptyInput(TypedDict):
    is_empty: bool


CareerLevelListFilter = Union[
    _CareerLevelListFilterHasInput,
    _CareerLevelListFilterEqualsInput,
    _CareerLevelListFilterHasSomeInput,
    _CareerLevelListFilterIsEmptyInput,
    _CareerLevelListFilterHasEveryInput,
]


class _CareerLevelListUpdateSet(TypedDict):
    set: List['enums.CareerLevel']


class _CareerLevelListUpdatePush(TypedDict):
    push: List['enums.CareerLevel']


CareerLevelListUpdate = Union[
    List['enums.CareerLevel'],
    _CareerLevelListUpdateSet,
    _CareerLevelListUpdatePush,
]

class _EducationLevelListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.EducationLevel']]


class _EducationLevelListFilterHasInput(TypedDict):
    has: 'enums.EducationLevel'


class _EducationLevelListFilterHasEveryInput(TypedDict):
    has_every: List['enums.EducationLevel']


class _EducationLevelListFilterHasSomeInput(TypedDict):
    has_some: List['enums.EducationLevel']


class _EducationLevelListFilterIsEmptyInput(TypedDict):
    is_empty: bool


EducationLevelListFilter = Union[
    _EducationLevelListFilterHasInput,
    _EducationLevelListFilterEqualsInput,
    _EducationLevelListFilterHasSomeInput,
    _EducationLevelListFilterIsEmptyInput,
    _EducationLevelListFilterHasEveryInput,
]


class _EducationLevelListUpdateSet(TypedDict):
    set: List['enums.EducationLevel']


class _EducationLevelListUpdatePush(TypedDict):
    push: List['enums.EducationLevel']


EducationLevelListUpdate = Union[
    List['enums.EducationLevel'],
    _EducationLevelListUpdateSet,
    _EducationLevelListUpdatePush,
]

class _CandidateStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.CandidateStatus']]


class _CandidateStatusListFilterHasInput(TypedDict):
    has: 'enums.CandidateStatus'


class _CandidateStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.CandidateStatus']


class _CandidateStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.CandidateStatus']


class _CandidateStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


CandidateStatusListFilter = Union[
    _CandidateStatusListFilterHasInput,
    _CandidateStatusListFilterEqualsInput,
    _CandidateStatusListFilterHasSomeInput,
    _CandidateStatusListFilterIsEmptyInput,
    _CandidateStatusListFilterHasEveryInput,
]


class _CandidateStatusListUpdateSet(TypedDict):
    set: List['enums.CandidateStatus']


class _CandidateStatusListUpdatePush(TypedDict):
    push: List['enums.CandidateStatus']


CandidateStatusListUpdate = Union[
    List['enums.CandidateStatus'],
    _CandidateStatusListUpdateSet,
    _CandidateStatusListUpdatePush,
]

class _CandidateSourceListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.CandidateSource']]


class _CandidateSourceListFilterHasInput(TypedDict):
    has: 'enums.CandidateSource'


class _CandidateSourceListFilterHasEveryInput(TypedDict):
    has_every: List['enums.CandidateSource']


class _CandidateSourceListFilterHasSomeInput(TypedDict):
    has_some: List['enums.CandidateSource']


class _CandidateSourceListFilterIsEmptyInput(TypedDict):
    is_empty: bool


CandidateSourceListFilter = Union[
    _CandidateSourceListFilterHasInput,
    _CandidateSourceListFilterEqualsInput,
    _CandidateSourceListFilterHasSomeInput,
    _CandidateSourceListFilterIsEmptyInput,
    _CandidateSourceListFilterHasEveryInput,
]


class _CandidateSourceListUpdateSet(TypedDict):
    set: List['enums.CandidateSource']


class _CandidateSourceListUpdatePush(TypedDict):
    push: List['enums.CandidateSource']


CandidateSourceListUpdate = Union[
    List['enums.CandidateSource'],
    _CandidateSourceListUpdateSet,
    _CandidateSourceListUpdatePush,
]

class _JobStatusListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.JobStatus']]


class _JobStatusListFilterHasInput(TypedDict):
    has: 'enums.JobStatus'


class _JobStatusListFilterHasEveryInput(TypedDict):
    has_every: List['enums.JobStatus']


class _JobStatusListFilterHasSomeInput(TypedDict):
    has_some: List['enums.JobStatus']


class _JobStatusListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JobStatusListFilter = Union[
    _JobStatusListFilterHasInput,
    _JobStatusListFilterEqualsInput,
    _JobStatusListFilterHasSomeInput,
    _JobStatusListFilterIsEmptyInput,
    _JobStatusListFilterHasEveryInput,
]


class _JobStatusListUpdateSet(TypedDict):
    set: List['enums.JobStatus']


class _JobStatusListUpdatePush(TypedDict):
    push: List['enums.JobStatus']


JobStatusListUpdate = Union[
    List['enums.JobStatus'],
    _JobStatusListUpdateSet,
    _JobStatusListUpdatePush,
]

class _AgentTypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.AgentType']]


class _AgentTypeListFilterHasInput(TypedDict):
    has: 'enums.AgentType'


class _AgentTypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.AgentType']


class _AgentTypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.AgentType']


class _AgentTypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


AgentTypeListFilter = Union[
    _AgentTypeListFilterHasInput,
    _AgentTypeListFilterEqualsInput,
    _AgentTypeListFilterHasSomeInput,
    _AgentTypeListFilterIsEmptyInput,
    _AgentTypeListFilterHasEveryInput,
]


class _AgentTypeListUpdateSet(TypedDict):
    set: List['enums.AgentType']


class _AgentTypeListUpdatePush(TypedDict):
    push: List['enums.AgentType']


AgentTypeListUpdate = Union[
    List['enums.AgentType'],
    _AgentTypeListUpdateSet,
    _AgentTypeListUpdatePush,
]


# License types

class LicenseOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the License create method"""
    id: _str
    type: 'enums.LicenseType'
    tenants: 'TenantCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class LicenseCreateInput(LicenseOptionalCreateInput):
    """Required arguments to the License create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class LicenseOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the License create method, without relations"""
    id: _str
    type: 'enums.LicenseType'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class LicenseCreateWithoutRelationsInput(LicenseOptionalCreateWithoutRelationsInput):
    """Required arguments to the License create method, without relations"""

class LicenseConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'LicenseCreateWithoutRelationsInput'
    where: 'LicenseWhereUniqueInput'

class LicenseCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'LicenseCreateWithoutRelationsInput'
    connect: 'LicenseWhereUniqueInput'
    connect_or_create: 'LicenseConnectOrCreateWithoutRelationsInput'


class LicenseCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['LicenseCreateWithoutRelationsInput', List['LicenseCreateWithoutRelationsInput']]
    connect: Union['LicenseWhereUniqueInput', List['LicenseWhereUniqueInput']]
    connect_or_create: Union['LicenseConnectOrCreateWithoutRelationsInput', List['LicenseConnectOrCreateWithoutRelationsInput']]

_LicenseWhereUnique_id_Input = TypedDict(
    '_LicenseWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

LicenseWhereUniqueInput = _LicenseWhereUnique_id_Input


class LicenseUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    type: 'enums.LicenseType'
    tenants: 'TenantUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class LicenseUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    type: 'enums.LicenseType'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class LicenseUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['LicenseCreateWithoutRelationsInput']
    connect: List['LicenseWhereUniqueInput']
    connect_or_create: List['LicenseConnectOrCreateWithoutRelationsInput']
    set: List['LicenseWhereUniqueInput']
    disconnect: List['LicenseWhereUniqueInput']
    delete: List['LicenseWhereUniqueInput']

    # TODO
    # update: List['LicenseUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['LicenseUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['LicenseScalarWhereInput']
    # upsert: List['LicenseUpserteWithWhereUniqueWithoutRelationsInput']


class LicenseUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'LicenseCreateWithoutRelationsInput'
    connect: 'LicenseWhereUniqueInput'
    connect_or_create: 'LicenseConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'LicenseUpdateInput'
    # upsert: 'LicenseUpsertWithoutRelationsInput'


class LicenseUpsertInput(TypedDict):
    create: 'LicenseCreateInput'
    update: 'LicenseUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_License_id_OrderByInput = TypedDict(
    '_License_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_License_type_OrderByInput = TypedDict(
    '_License_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_License_createdAt_OrderByInput = TypedDict(
    '_License_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_License_updatedAt_OrderByInput = TypedDict(
    '_License_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_License_deleted_OrderByInput = TypedDict(
    '_License_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_License_deletedAt_OrderByInput = TypedDict(
    '_License_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_License_RelevanceInner = TypedDict(
    '_License_RelevanceInner',
    {
        'fields': 'List[LicenseScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_License_RelevanceOrderByInput = TypedDict(
    '_License_RelevanceOrderByInput',
    {
        '_relevance': '_License_RelevanceInner',
    },
    total=True
)

LicenseOrderByInput = Union[
    '_License_id_OrderByInput',
    '_License_type_OrderByInput',
    '_License_createdAt_OrderByInput',
    '_License_updatedAt_OrderByInput',
    '_License_deleted_OrderByInput',
    '_License_deletedAt_OrderByInput',
    '_License_RelevanceOrderByInput',
]



# recursive License types
# TODO: cleanup these types



LicenseRelationFilter = TypedDict(
    'LicenseRelationFilter',
    {
        'is': 'LicenseWhereInput',
        'is_not': 'LicenseWhereInput',
    },
    total=False,
)


class LicenseListRelationFilter(TypedDict, total=False):
    some: 'LicenseWhereInput'
    none: 'LicenseWhereInput'
    every: 'LicenseWhereInput'


class LicenseInclude(TypedDict, total=False):
    """License relational arguments"""
    tenants: Union[bool, 'FindManyTenantArgsFromLicense']


class LicenseIncludeFromLicense(TypedDict, total=False):
    """Relational arguments for License"""
    tenants: Union[bool, 'FindManyTenantArgsFromLicense']


class LicenseArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    include: 'LicenseIncludeFromLicense'


class FindManyLicenseArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    take: int
    skip: int
    order_by: Union['LicenseOrderByInput', List['LicenseOrderByInput']]
    where: 'LicenseWhereInput'
    cursor: 'LicenseWhereUniqueInput'
    distinct: List['LicenseScalarFieldKeys']
    include: 'LicenseIncludeFromLicense'


class TenantIncludeFromLicense(TypedDict, total=False):
    """Relational arguments for License"""
    users: Union[bool, 'FindManyUserArgsFromLicense']
    projects: Union[bool, 'FindManyProjectArgsFromLicense']
    jobs: Union[bool, 'FindManyJobArgsFromLicense']
    agents: Union[bool, 'FindManyAgentArgsFromLicense']
    candidates: Union[bool, 'FindManyCandidateArgsFromLicense']
    license: Union[bool, 'LicenseArgsFromLicense']


class TenantArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class UserRoleIncludeFromLicense(TypedDict, total=False):
    """Relational arguments for License"""
    users: Union[bool, 'FindManyUserArgsFromLicense']


class UserRoleArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    include: 'UserRoleIncludeFromUserRole'


class FindManyUserRoleArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    take: int
    skip: int
    order_by: Union['UserRoleOrderByInput', List['UserRoleOrderByInput']]
    where: 'UserRoleWhereInput'
    cursor: 'UserRoleWhereUniqueInput'
    distinct: List['UserRoleScalarFieldKeys']
    include: 'UserRoleIncludeFromUserRole'


class UserIncludeFromLicense(TypedDict, total=False):
    """Relational arguments for License"""
    role: Union[bool, 'UserRoleArgsFromLicense']
    tenant: Union[bool, 'TenantArgsFromLicense']
    projects: Union[bool, 'FindManyProjectArgsFromLicense']
    sessions: Union[bool, 'FindManyUserSessionArgsFromLicense']


class UserArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserSessionIncludeFromLicense(TypedDict, total=False):
    """Relational arguments for License"""
    user: Union[bool, 'UserArgsFromLicense']


class UserSessionArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    include: 'UserSessionIncludeFromUserSession'


class FindManyUserSessionArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    take: int
    skip: int
    order_by: Union['UserSessionOrderByInput', List['UserSessionOrderByInput']]
    where: 'UserSessionWhereInput'
    cursor: 'UserSessionWhereUniqueInput'
    distinct: List['UserSessionScalarFieldKeys']
    include: 'UserSessionIncludeFromUserSession'


class CandidateIncludeFromLicense(TypedDict, total=False):
    """Relational arguments for License"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromLicense']
    tenant: Union[bool, 'TenantArgsFromLicense']


class CandidateArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    include: 'CandidateIncludeFromCandidate'


class FindManyCandidateArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidate'


class JobIncludeFromLicense(TypedDict, total=False):
    """Relational arguments for License"""
    tenant: Union[bool, 'TenantArgsFromLicense']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromLicense']


class JobArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    include: 'JobIncludeFromJob'


class FindManyJobArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJob'


class JobCandidateIncludeFromLicense(TypedDict, total=False):
    """Relational arguments for License"""
    job: Union[bool, 'JobArgsFromLicense']
    candidate: Union[bool, 'CandidateArgsFromLicense']


class JobCandidateArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    include: 'JobCandidateIncludeFromJobCandidate'


class FindManyJobCandidateArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    take: int
    skip: int
    order_by: Union['JobCandidateOrderByInput', List['JobCandidateOrderByInput']]
    where: 'JobCandidateWhereInput'
    cursor: 'JobCandidateWhereUniqueInput'
    distinct: List['JobCandidateScalarFieldKeys']
    include: 'JobCandidateIncludeFromJobCandidate'


class ProjectIncludeFromLicense(TypedDict, total=False):
    """Relational arguments for License"""
    tenant: Union[bool, 'TenantArgsFromLicense']
    user: Union[bool, 'UserArgsFromLicense']


class ProjectArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    include: 'ProjectIncludeFromProject'


class FindManyProjectArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProject'


class AgentIncludeFromLicense(TypedDict, total=False):
    """Relational arguments for License"""
    tenant: Union[bool, 'TenantArgsFromLicense']
    conversations: Union[bool, 'FindManyConversationArgsFromLicense']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromLicense']


class AgentArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    include: 'AgentIncludeFromAgent'


class FindManyAgentArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    take: int
    skip: int
    order_by: Union['AgentOrderByInput', List['AgentOrderByInput']]
    where: 'AgentWhereInput'
    cursor: 'AgentWhereUniqueInput'
    distinct: List['AgentScalarFieldKeys']
    include: 'AgentIncludeFromAgent'


class ConversationIncludeFromLicense(TypedDict, total=False):
    """Relational arguments for License"""
    agent: Union[bool, 'AgentArgsFromLicense']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromLicense']


class ConversationArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    include: 'ConversationIncludeFromConversation'


class FindManyConversationArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversation'


class AgentTaskIncludeFromLicense(TypedDict, total=False):
    """Relational arguments for License"""
    agent: Union[bool, 'AgentArgsFromLicense']
    conversation: Union[bool, 'ConversationArgsFromLicense']


class AgentTaskArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    include: 'AgentTaskIncludeFromAgentTask'


class FindManyAgentTaskArgsFromLicense(TypedDict, total=False):
    """Arguments for License"""
    take: int
    skip: int
    order_by: Union['AgentTaskOrderByInput', List['AgentTaskOrderByInput']]
    where: 'AgentTaskWhereInput'
    cursor: 'AgentTaskWhereUniqueInput'
    distinct: List['AgentTaskScalarFieldKeys']
    include: 'AgentTaskIncludeFromAgentTask'




FindManyLicenseArgs = FindManyLicenseArgsFromLicense
FindFirstLicenseArgs = FindManyLicenseArgsFromLicense


class LicenseWhereInput(TypedDict, total=False):
    """License arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    type: 'enums.LicenseType'
    tenants: 'TenantListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['LicenseWhereInput', List['LicenseWhereInput']]
    # but this causes mypy to hang :/
    AND: List['LicenseWhereInput']
    OR: List['LicenseWhereInput']
    NOT: List['LicenseWhereInput']



# aggregate License types


class LicenseScalarWhereWithAggregatesInput(TypedDict, total=False):
    """License arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.LicenseType'
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['LicenseScalarWhereWithAggregatesInput']
    OR: List['LicenseScalarWhereWithAggregatesInput']
    NOT: List['LicenseScalarWhereWithAggregatesInput']



class LicenseGroupByOutput(TypedDict, total=False):
    id: _str
    type: 'enums.LicenseType'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime
    _sum: 'LicenseSumAggregateOutput'
    _avg: 'LicenseAvgAggregateOutput'
    _min: 'LicenseMinAggregateOutput'
    _max: 'LicenseMaxAggregateOutput'
    _count: 'LicenseCountAggregateOutput'


class LicenseAvgAggregateOutput(TypedDict, total=False):
    """License output for aggregating averages"""


class LicenseSumAggregateOutput(TypedDict, total=False):
    """License output for aggregating sums"""


class LicenseScalarAggregateOutput(TypedDict, total=False):
    """License output including scalar fields"""
    id: _str
    type: 'enums.LicenseType'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime


LicenseMinAggregateOutput = LicenseScalarAggregateOutput
LicenseMaxAggregateOutput = LicenseScalarAggregateOutput


class LicenseMaxAggregateInput(TypedDict, total=False):
    """License input for aggregating by max"""
    id: bool
    type: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class LicenseMinAggregateInput(TypedDict, total=False):
    """License input for aggregating by min"""
    id: bool
    type: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class LicenseNumberAggregateInput(TypedDict, total=False):
    """License input for aggregating numbers"""


LicenseAvgAggregateInput = LicenseNumberAggregateInput
LicenseSumAggregateInput = LicenseNumberAggregateInput


LicenseCountAggregateInput = TypedDict(
    'LicenseCountAggregateInput',
    {
        'id': bool,
        'type': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deleted': bool,
        'deletedAt': bool,
        '_all': bool,
    },
    total=False,
)

LicenseCountAggregateOutput = TypedDict(
    'LicenseCountAggregateOutput',
    {
        'id': int,
        'type': int,
        'createdAt': int,
        'updatedAt': int,
        'deleted': int,
        'deletedAt': int,
        '_all': int,
    },
    total=False,
)


LicenseKeys = Literal[
    'id',
    'type',
    'tenants',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
LicenseScalarFieldKeys = Literal[
    'id',
    'type',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
LicenseScalarFieldKeysT = TypeVar('LicenseScalarFieldKeysT', bound=LicenseScalarFieldKeys)

LicenseRelationalFieldKeys = Literal[
        'tenants',
    ]

# Tenant types

class TenantOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Tenant create method"""
    id: _str
    billingEmail: Optional[_str]
    billingPhone: Optional[_str]
    billingAddress: Optional[_str]
    billingAddress2: Optional[_str]
    billingCity: Optional[_str]
    billingState: Optional[_str]
    billingZip: Optional[_str]
    billingCountry: Optional[_str]
    billingVatNumber: Optional[_str]
    users: 'UserCreateManyNestedWithoutRelationsInput'
    projects: 'ProjectCreateManyNestedWithoutRelationsInput'
    jobs: 'JobCreateManyNestedWithoutRelationsInput'
    agents: 'AgentCreateManyNestedWithoutRelationsInput'
    candidates: 'CandidateCreateManyNestedWithoutRelationsInput'
    licenseId: Optional[_str]
    license: 'LicenseCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class TenantCreateInput(TenantOptionalCreateInput):
    """Required arguments to the Tenant create method"""
    name: _str
    slug: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class TenantOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Tenant create method, without relations"""
    id: _str
    billingEmail: Optional[_str]
    billingPhone: Optional[_str]
    billingAddress: Optional[_str]
    billingAddress2: Optional[_str]
    billingCity: Optional[_str]
    billingState: Optional[_str]
    billingZip: Optional[_str]
    billingCountry: Optional[_str]
    billingVatNumber: Optional[_str]
    licenseId: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class TenantCreateWithoutRelationsInput(TenantOptionalCreateWithoutRelationsInput):
    """Required arguments to the Tenant create method, without relations"""
    name: _str
    slug: _str

class TenantConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'TenantCreateWithoutRelationsInput'
    where: 'TenantWhereUniqueInput'

class TenantCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'TenantCreateWithoutRelationsInput'
    connect: 'TenantWhereUniqueInput'
    connect_or_create: 'TenantConnectOrCreateWithoutRelationsInput'


class TenantCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['TenantCreateWithoutRelationsInput', List['TenantCreateWithoutRelationsInput']]
    connect: Union['TenantWhereUniqueInput', List['TenantWhereUniqueInput']]
    connect_or_create: Union['TenantConnectOrCreateWithoutRelationsInput', List['TenantConnectOrCreateWithoutRelationsInput']]

_TenantWhereUnique_id_Input = TypedDict(
    '_TenantWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_TenantWhereUnique_slug_Input = TypedDict(
    '_TenantWhereUnique_slug_Input',
    {
        'slug': '_str',
    },
    total=True
)

TenantWhereUniqueInput = Union[
    '_TenantWhereUnique_id_Input',
    '_TenantWhereUnique_slug_Input',
]


class TenantUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    slug: _str
    billingEmail: Optional[_str]
    billingPhone: Optional[_str]
    billingAddress: Optional[_str]
    billingAddress2: Optional[_str]
    billingCity: Optional[_str]
    billingState: Optional[_str]
    billingZip: Optional[_str]
    billingCountry: Optional[_str]
    billingVatNumber: Optional[_str]
    users: 'UserUpdateManyWithoutRelationsInput'
    projects: 'ProjectUpdateManyWithoutRelationsInput'
    jobs: 'JobUpdateManyWithoutRelationsInput'
    agents: 'AgentUpdateManyWithoutRelationsInput'
    candidates: 'CandidateUpdateManyWithoutRelationsInput'
    license: 'LicenseUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class TenantUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    slug: _str
    billingEmail: Optional[_str]
    billingPhone: Optional[_str]
    billingAddress: Optional[_str]
    billingAddress2: Optional[_str]
    billingCity: Optional[_str]
    billingState: Optional[_str]
    billingZip: Optional[_str]
    billingCountry: Optional[_str]
    billingVatNumber: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class TenantUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['TenantCreateWithoutRelationsInput']
    connect: List['TenantWhereUniqueInput']
    connect_or_create: List['TenantConnectOrCreateWithoutRelationsInput']
    set: List['TenantWhereUniqueInput']
    disconnect: List['TenantWhereUniqueInput']
    delete: List['TenantWhereUniqueInput']

    # TODO
    # update: List['TenantUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['TenantUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['TenantScalarWhereInput']
    # upsert: List['TenantUpserteWithWhereUniqueWithoutRelationsInput']


class TenantUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'TenantCreateWithoutRelationsInput'
    connect: 'TenantWhereUniqueInput'
    connect_or_create: 'TenantConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'TenantUpdateInput'
    # upsert: 'TenantUpsertWithoutRelationsInput'


class TenantUpsertInput(TypedDict):
    create: 'TenantCreateInput'
    update: 'TenantUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Tenant_id_OrderByInput = TypedDict(
    '_Tenant_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Tenant_name_OrderByInput = TypedDict(
    '_Tenant_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Tenant_slug_OrderByInput = TypedDict(
    '_Tenant_slug_OrderByInput',
    {
        'slug': 'SortOrder',
    },
    total=True
)

_Tenant_billingEmail_OrderByInput = TypedDict(
    '_Tenant_billingEmail_OrderByInput',
    {
        'billingEmail': 'SortOrder',
    },
    total=True
)

_Tenant_billingPhone_OrderByInput = TypedDict(
    '_Tenant_billingPhone_OrderByInput',
    {
        'billingPhone': 'SortOrder',
    },
    total=True
)

_Tenant_billingAddress_OrderByInput = TypedDict(
    '_Tenant_billingAddress_OrderByInput',
    {
        'billingAddress': 'SortOrder',
    },
    total=True
)

_Tenant_billingAddress2_OrderByInput = TypedDict(
    '_Tenant_billingAddress2_OrderByInput',
    {
        'billingAddress2': 'SortOrder',
    },
    total=True
)

_Tenant_billingCity_OrderByInput = TypedDict(
    '_Tenant_billingCity_OrderByInput',
    {
        'billingCity': 'SortOrder',
    },
    total=True
)

_Tenant_billingState_OrderByInput = TypedDict(
    '_Tenant_billingState_OrderByInput',
    {
        'billingState': 'SortOrder',
    },
    total=True
)

_Tenant_billingZip_OrderByInput = TypedDict(
    '_Tenant_billingZip_OrderByInput',
    {
        'billingZip': 'SortOrder',
    },
    total=True
)

_Tenant_billingCountry_OrderByInput = TypedDict(
    '_Tenant_billingCountry_OrderByInput',
    {
        'billingCountry': 'SortOrder',
    },
    total=True
)

_Tenant_billingVatNumber_OrderByInput = TypedDict(
    '_Tenant_billingVatNumber_OrderByInput',
    {
        'billingVatNumber': 'SortOrder',
    },
    total=True
)

_Tenant_licenseId_OrderByInput = TypedDict(
    '_Tenant_licenseId_OrderByInput',
    {
        'licenseId': 'SortOrder',
    },
    total=True
)

_Tenant_createdAt_OrderByInput = TypedDict(
    '_Tenant_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Tenant_updatedAt_OrderByInput = TypedDict(
    '_Tenant_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Tenant_deleted_OrderByInput = TypedDict(
    '_Tenant_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_Tenant_deletedAt_OrderByInput = TypedDict(
    '_Tenant_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_Tenant_RelevanceInner = TypedDict(
    '_Tenant_RelevanceInner',
    {
        'fields': 'List[TenantScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Tenant_RelevanceOrderByInput = TypedDict(
    '_Tenant_RelevanceOrderByInput',
    {
        '_relevance': '_Tenant_RelevanceInner',
    },
    total=True
)

TenantOrderByInput = Union[
    '_Tenant_id_OrderByInput',
    '_Tenant_name_OrderByInput',
    '_Tenant_slug_OrderByInput',
    '_Tenant_billingEmail_OrderByInput',
    '_Tenant_billingPhone_OrderByInput',
    '_Tenant_billingAddress_OrderByInput',
    '_Tenant_billingAddress2_OrderByInput',
    '_Tenant_billingCity_OrderByInput',
    '_Tenant_billingState_OrderByInput',
    '_Tenant_billingZip_OrderByInput',
    '_Tenant_billingCountry_OrderByInput',
    '_Tenant_billingVatNumber_OrderByInput',
    '_Tenant_licenseId_OrderByInput',
    '_Tenant_createdAt_OrderByInput',
    '_Tenant_updatedAt_OrderByInput',
    '_Tenant_deleted_OrderByInput',
    '_Tenant_deletedAt_OrderByInput',
    '_Tenant_RelevanceOrderByInput',
]



# recursive Tenant types
# TODO: cleanup these types



TenantRelationFilter = TypedDict(
    'TenantRelationFilter',
    {
        'is': 'TenantWhereInput',
        'is_not': 'TenantWhereInput',
    },
    total=False,
)


class TenantListRelationFilter(TypedDict, total=False):
    some: 'TenantWhereInput'
    none: 'TenantWhereInput'
    every: 'TenantWhereInput'


class TenantInclude(TypedDict, total=False):
    """Tenant relational arguments"""
    users: Union[bool, 'FindManyUserArgsFromTenant']
    projects: Union[bool, 'FindManyProjectArgsFromTenant']
    jobs: Union[bool, 'FindManyJobArgsFromTenant']
    agents: Union[bool, 'FindManyAgentArgsFromTenant']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenant']
    license: Union[bool, 'LicenseArgsFromTenant']


class LicenseIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenants: Union[bool, 'FindManyTenantArgsFromTenant']


class LicenseArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'LicenseIncludeFromLicense'


class FindManyLicenseArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['LicenseOrderByInput', List['LicenseOrderByInput']]
    where: 'LicenseWhereInput'
    cursor: 'LicenseWhereUniqueInput'
    distinct: List['LicenseScalarFieldKeys']
    include: 'LicenseIncludeFromLicense'


class TenantIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    users: Union[bool, 'FindManyUserArgsFromTenant']
    projects: Union[bool, 'FindManyProjectArgsFromTenant']
    jobs: Union[bool, 'FindManyJobArgsFromTenant']
    agents: Union[bool, 'FindManyAgentArgsFromTenant']
    candidates: Union[bool, 'FindManyCandidateArgsFromTenant']
    license: Union[bool, 'LicenseArgsFromTenant']


class TenantArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class UserRoleIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    users: Union[bool, 'FindManyUserArgsFromTenant']


class UserRoleArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'UserRoleIncludeFromUserRole'


class FindManyUserRoleArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['UserRoleOrderByInput', List['UserRoleOrderByInput']]
    where: 'UserRoleWhereInput'
    cursor: 'UserRoleWhereUniqueInput'
    distinct: List['UserRoleScalarFieldKeys']
    include: 'UserRoleIncludeFromUserRole'


class UserIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    role: Union[bool, 'UserRoleArgsFromTenant']
    tenant: Union[bool, 'TenantArgsFromTenant']
    projects: Union[bool, 'FindManyProjectArgsFromTenant']
    sessions: Union[bool, 'FindManyUserSessionArgsFromTenant']


class UserArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserSessionIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    user: Union[bool, 'UserArgsFromTenant']


class UserSessionArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'UserSessionIncludeFromUserSession'


class FindManyUserSessionArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['UserSessionOrderByInput', List['UserSessionOrderByInput']]
    where: 'UserSessionWhereInput'
    cursor: 'UserSessionWhereUniqueInput'
    distinct: List['UserSessionScalarFieldKeys']
    include: 'UserSessionIncludeFromUserSession'


class CandidateIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromTenant']
    tenant: Union[bool, 'TenantArgsFromTenant']


class CandidateArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'CandidateIncludeFromCandidate'


class FindManyCandidateArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidate'


class JobIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenant']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromTenant']


class JobArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'JobIncludeFromJob'


class FindManyJobArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJob'


class JobCandidateIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    job: Union[bool, 'JobArgsFromTenant']
    candidate: Union[bool, 'CandidateArgsFromTenant']


class JobCandidateArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'JobCandidateIncludeFromJobCandidate'


class FindManyJobCandidateArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['JobCandidateOrderByInput', List['JobCandidateOrderByInput']]
    where: 'JobCandidateWhereInput'
    cursor: 'JobCandidateWhereUniqueInput'
    distinct: List['JobCandidateScalarFieldKeys']
    include: 'JobCandidateIncludeFromJobCandidate'


class ProjectIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenant']
    user: Union[bool, 'UserArgsFromTenant']


class ProjectArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'ProjectIncludeFromProject'


class FindManyProjectArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProject'


class AgentIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    tenant: Union[bool, 'TenantArgsFromTenant']
    conversations: Union[bool, 'FindManyConversationArgsFromTenant']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromTenant']


class AgentArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'AgentIncludeFromAgent'


class FindManyAgentArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['AgentOrderByInput', List['AgentOrderByInput']]
    where: 'AgentWhereInput'
    cursor: 'AgentWhereUniqueInput'
    distinct: List['AgentScalarFieldKeys']
    include: 'AgentIncludeFromAgent'


class ConversationIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    agent: Union[bool, 'AgentArgsFromTenant']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromTenant']


class ConversationArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'ConversationIncludeFromConversation'


class FindManyConversationArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversation'


class AgentTaskIncludeFromTenant(TypedDict, total=False):
    """Relational arguments for Tenant"""
    agent: Union[bool, 'AgentArgsFromTenant']
    conversation: Union[bool, 'ConversationArgsFromTenant']


class AgentTaskArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    include: 'AgentTaskIncludeFromAgentTask'


class FindManyAgentTaskArgsFromTenant(TypedDict, total=False):
    """Arguments for Tenant"""
    take: int
    skip: int
    order_by: Union['AgentTaskOrderByInput', List['AgentTaskOrderByInput']]
    where: 'AgentTaskWhereInput'
    cursor: 'AgentTaskWhereUniqueInput'
    distinct: List['AgentTaskScalarFieldKeys']
    include: 'AgentTaskIncludeFromAgentTask'




FindManyTenantArgs = FindManyTenantArgsFromTenant
FindFirstTenantArgs = FindManyTenantArgsFromTenant


class TenantWhereInput(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    slug: Union[_str, 'types.StringFilter']
    billingEmail: Union[None, _str, 'types.StringFilter']
    billingPhone: Union[None, _str, 'types.StringFilter']
    billingAddress: Union[None, _str, 'types.StringFilter']
    billingAddress2: Union[None, _str, 'types.StringFilter']
    billingCity: Union[None, _str, 'types.StringFilter']
    billingState: Union[None, _str, 'types.StringFilter']
    billingZip: Union[None, _str, 'types.StringFilter']
    billingCountry: Union[None, _str, 'types.StringFilter']
    billingVatNumber: Union[None, _str, 'types.StringFilter']
    users: 'UserListRelationFilter'
    projects: 'ProjectListRelationFilter'
    jobs: 'JobListRelationFilter'
    agents: 'AgentListRelationFilter'
    candidates: 'CandidateListRelationFilter'
    licenseId: Union[None, _str, 'types.StringFilter']
    license: 'LicenseRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['TenantWhereInput', List['TenantWhereInput']]
    # but this causes mypy to hang :/
    AND: List['TenantWhereInput']
    OR: List['TenantWhereInput']
    NOT: List['TenantWhereInput']



# aggregate Tenant types


class TenantScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Tenant arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    slug: Union[_str, 'types.StringWithAggregatesFilter']
    billingEmail: Union[_str, 'types.StringWithAggregatesFilter']
    billingPhone: Union[_str, 'types.StringWithAggregatesFilter']
    billingAddress: Union[_str, 'types.StringWithAggregatesFilter']
    billingAddress2: Union[_str, 'types.StringWithAggregatesFilter']
    billingCity: Union[_str, 'types.StringWithAggregatesFilter']
    billingState: Union[_str, 'types.StringWithAggregatesFilter']
    billingZip: Union[_str, 'types.StringWithAggregatesFilter']
    billingCountry: Union[_str, 'types.StringWithAggregatesFilter']
    billingVatNumber: Union[_str, 'types.StringWithAggregatesFilter']
    licenseId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['TenantScalarWhereWithAggregatesInput']
    OR: List['TenantScalarWhereWithAggregatesInput']
    NOT: List['TenantScalarWhereWithAggregatesInput']



class TenantGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    slug: _str
    billingEmail: _str
    billingPhone: _str
    billingAddress: _str
    billingAddress2: _str
    billingCity: _str
    billingState: _str
    billingZip: _str
    billingCountry: _str
    billingVatNumber: _str
    licenseId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime
    _sum: 'TenantSumAggregateOutput'
    _avg: 'TenantAvgAggregateOutput'
    _min: 'TenantMinAggregateOutput'
    _max: 'TenantMaxAggregateOutput'
    _count: 'TenantCountAggregateOutput'


class TenantAvgAggregateOutput(TypedDict, total=False):
    """Tenant output for aggregating averages"""


class TenantSumAggregateOutput(TypedDict, total=False):
    """Tenant output for aggregating sums"""


class TenantScalarAggregateOutput(TypedDict, total=False):
    """Tenant output including scalar fields"""
    id: _str
    name: _str
    slug: _str
    billingEmail: _str
    billingPhone: _str
    billingAddress: _str
    billingAddress2: _str
    billingCity: _str
    billingState: _str
    billingZip: _str
    billingCountry: _str
    billingVatNumber: _str
    licenseId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime


TenantMinAggregateOutput = TenantScalarAggregateOutput
TenantMaxAggregateOutput = TenantScalarAggregateOutput


class TenantMaxAggregateInput(TypedDict, total=False):
    """Tenant input for aggregating by max"""
    id: bool
    name: bool
    slug: bool
    billingEmail: bool
    billingPhone: bool
    billingAddress: bool
    billingAddress2: bool
    billingCity: bool
    billingState: bool
    billingZip: bool
    billingCountry: bool
    billingVatNumber: bool
    licenseId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class TenantMinAggregateInput(TypedDict, total=False):
    """Tenant input for aggregating by min"""
    id: bool
    name: bool
    slug: bool
    billingEmail: bool
    billingPhone: bool
    billingAddress: bool
    billingAddress2: bool
    billingCity: bool
    billingState: bool
    billingZip: bool
    billingCountry: bool
    billingVatNumber: bool
    licenseId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class TenantNumberAggregateInput(TypedDict, total=False):
    """Tenant input for aggregating numbers"""


TenantAvgAggregateInput = TenantNumberAggregateInput
TenantSumAggregateInput = TenantNumberAggregateInput


TenantCountAggregateInput = TypedDict(
    'TenantCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'slug': bool,
        'billingEmail': bool,
        'billingPhone': bool,
        'billingAddress': bool,
        'billingAddress2': bool,
        'billingCity': bool,
        'billingState': bool,
        'billingZip': bool,
        'billingCountry': bool,
        'billingVatNumber': bool,
        'licenseId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deleted': bool,
        'deletedAt': bool,
        '_all': bool,
    },
    total=False,
)

TenantCountAggregateOutput = TypedDict(
    'TenantCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'slug': int,
        'billingEmail': int,
        'billingPhone': int,
        'billingAddress': int,
        'billingAddress2': int,
        'billingCity': int,
        'billingState': int,
        'billingZip': int,
        'billingCountry': int,
        'billingVatNumber': int,
        'licenseId': int,
        'createdAt': int,
        'updatedAt': int,
        'deleted': int,
        'deletedAt': int,
        '_all': int,
    },
    total=False,
)


TenantKeys = Literal[
    'id',
    'name',
    'slug',
    'billingEmail',
    'billingPhone',
    'billingAddress',
    'billingAddress2',
    'billingCity',
    'billingState',
    'billingZip',
    'billingCountry',
    'billingVatNumber',
    'users',
    'projects',
    'jobs',
    'agents',
    'candidates',
    'licenseId',
    'license',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
TenantScalarFieldKeys = Literal[
    'id',
    'name',
    'slug',
    'billingEmail',
    'billingPhone',
    'billingAddress',
    'billingAddress2',
    'billingCity',
    'billingState',
    'billingZip',
    'billingCountry',
    'billingVatNumber',
    'licenseId',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
TenantScalarFieldKeysT = TypeVar('TenantScalarFieldKeysT', bound=TenantScalarFieldKeys)

TenantRelationalFieldKeys = Literal[
        'users',
        'projects',
        'jobs',
        'agents',
        'candidates',
        'license',
    ]

# UserRole types

class UserRoleOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the UserRole create method"""
    id: _str
    type: 'enums.UserRoleType'
    permissions: 'fields.Json'
    users: 'UserCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class UserRoleCreateInput(UserRoleOptionalCreateInput):
    """Required arguments to the UserRole create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserRoleOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the UserRole create method, without relations"""
    id: _str
    type: 'enums.UserRoleType'
    permissions: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class UserRoleCreateWithoutRelationsInput(UserRoleOptionalCreateWithoutRelationsInput):
    """Required arguments to the UserRole create method, without relations"""
    name: _str

class UserRoleConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserRoleCreateWithoutRelationsInput'
    where: 'UserRoleWhereUniqueInput'

class UserRoleCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserRoleCreateWithoutRelationsInput'
    connect: 'UserRoleWhereUniqueInput'
    connect_or_create: 'UserRoleConnectOrCreateWithoutRelationsInput'


class UserRoleCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserRoleCreateWithoutRelationsInput', List['UserRoleCreateWithoutRelationsInput']]
    connect: Union['UserRoleWhereUniqueInput', List['UserRoleWhereUniqueInput']]
    connect_or_create: Union['UserRoleConnectOrCreateWithoutRelationsInput', List['UserRoleConnectOrCreateWithoutRelationsInput']]

_UserRoleWhereUnique_id_Input = TypedDict(
    '_UserRoleWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

UserRoleWhereUniqueInput = _UserRoleWhereUnique_id_Input


class UserRoleUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    type: 'enums.UserRoleType'
    permissions: 'fields.Json'
    users: 'UserUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class UserRoleUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    type: 'enums.UserRoleType'
    permissions: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class UserRoleUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserRoleCreateWithoutRelationsInput']
    connect: List['UserRoleWhereUniqueInput']
    connect_or_create: List['UserRoleConnectOrCreateWithoutRelationsInput']
    set: List['UserRoleWhereUniqueInput']
    disconnect: List['UserRoleWhereUniqueInput']
    delete: List['UserRoleWhereUniqueInput']

    # TODO
    # update: List['UserRoleUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserRoleUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserRoleScalarWhereInput']
    # upsert: List['UserRoleUpserteWithWhereUniqueWithoutRelationsInput']


class UserRoleUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserRoleCreateWithoutRelationsInput'
    connect: 'UserRoleWhereUniqueInput'
    connect_or_create: 'UserRoleConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserRoleUpdateInput'
    # upsert: 'UserRoleUpsertWithoutRelationsInput'


class UserRoleUpsertInput(TypedDict):
    create: 'UserRoleCreateInput'
    update: 'UserRoleUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_UserRole_id_OrderByInput = TypedDict(
    '_UserRole_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_UserRole_name_OrderByInput = TypedDict(
    '_UserRole_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_UserRole_type_OrderByInput = TypedDict(
    '_UserRole_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_UserRole_permissions_OrderByInput = TypedDict(
    '_UserRole_permissions_OrderByInput',
    {
        'permissions': 'SortOrder',
    },
    total=True
)

_UserRole_createdAt_OrderByInput = TypedDict(
    '_UserRole_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_UserRole_updatedAt_OrderByInput = TypedDict(
    '_UserRole_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_UserRole_deleted_OrderByInput = TypedDict(
    '_UserRole_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_UserRole_deletedAt_OrderByInput = TypedDict(
    '_UserRole_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_UserRole_RelevanceInner = TypedDict(
    '_UserRole_RelevanceInner',
    {
        'fields': 'List[UserRoleScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_UserRole_RelevanceOrderByInput = TypedDict(
    '_UserRole_RelevanceOrderByInput',
    {
        '_relevance': '_UserRole_RelevanceInner',
    },
    total=True
)

UserRoleOrderByInput = Union[
    '_UserRole_id_OrderByInput',
    '_UserRole_name_OrderByInput',
    '_UserRole_type_OrderByInput',
    '_UserRole_permissions_OrderByInput',
    '_UserRole_createdAt_OrderByInput',
    '_UserRole_updatedAt_OrderByInput',
    '_UserRole_deleted_OrderByInput',
    '_UserRole_deletedAt_OrderByInput',
    '_UserRole_RelevanceOrderByInput',
]



# recursive UserRole types
# TODO: cleanup these types



UserRoleRelationFilter = TypedDict(
    'UserRoleRelationFilter',
    {
        'is': 'UserRoleWhereInput',
        'is_not': 'UserRoleWhereInput',
    },
    total=False,
)


class UserRoleListRelationFilter(TypedDict, total=False):
    some: 'UserRoleWhereInput'
    none: 'UserRoleWhereInput'
    every: 'UserRoleWhereInput'


class UserRoleInclude(TypedDict, total=False):
    """UserRole relational arguments"""
    users: Union[bool, 'FindManyUserArgsFromUserRole']


class LicenseIncludeFromUserRole(TypedDict, total=False):
    """Relational arguments for UserRole"""
    tenants: Union[bool, 'FindManyTenantArgsFromUserRole']


class LicenseArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    include: 'LicenseIncludeFromLicense'


class FindManyLicenseArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    take: int
    skip: int
    order_by: Union['LicenseOrderByInput', List['LicenseOrderByInput']]
    where: 'LicenseWhereInput'
    cursor: 'LicenseWhereUniqueInput'
    distinct: List['LicenseScalarFieldKeys']
    include: 'LicenseIncludeFromLicense'


class TenantIncludeFromUserRole(TypedDict, total=False):
    """Relational arguments for UserRole"""
    users: Union[bool, 'FindManyUserArgsFromUserRole']
    projects: Union[bool, 'FindManyProjectArgsFromUserRole']
    jobs: Union[bool, 'FindManyJobArgsFromUserRole']
    agents: Union[bool, 'FindManyAgentArgsFromUserRole']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserRole']
    license: Union[bool, 'LicenseArgsFromUserRole']


class TenantArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class UserRoleIncludeFromUserRole(TypedDict, total=False):
    """Relational arguments for UserRole"""
    users: Union[bool, 'FindManyUserArgsFromUserRole']


class UserRoleArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    include: 'UserRoleIncludeFromUserRole'


class FindManyUserRoleArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    take: int
    skip: int
    order_by: Union['UserRoleOrderByInput', List['UserRoleOrderByInput']]
    where: 'UserRoleWhereInput'
    cursor: 'UserRoleWhereUniqueInput'
    distinct: List['UserRoleScalarFieldKeys']
    include: 'UserRoleIncludeFromUserRole'


class UserIncludeFromUserRole(TypedDict, total=False):
    """Relational arguments for UserRole"""
    role: Union[bool, 'UserRoleArgsFromUserRole']
    tenant: Union[bool, 'TenantArgsFromUserRole']
    projects: Union[bool, 'FindManyProjectArgsFromUserRole']
    sessions: Union[bool, 'FindManyUserSessionArgsFromUserRole']


class UserArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserSessionIncludeFromUserRole(TypedDict, total=False):
    """Relational arguments for UserRole"""
    user: Union[bool, 'UserArgsFromUserRole']


class UserSessionArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    include: 'UserSessionIncludeFromUserSession'


class FindManyUserSessionArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    take: int
    skip: int
    order_by: Union['UserSessionOrderByInput', List['UserSessionOrderByInput']]
    where: 'UserSessionWhereInput'
    cursor: 'UserSessionWhereUniqueInput'
    distinct: List['UserSessionScalarFieldKeys']
    include: 'UserSessionIncludeFromUserSession'


class CandidateIncludeFromUserRole(TypedDict, total=False):
    """Relational arguments for UserRole"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromUserRole']
    tenant: Union[bool, 'TenantArgsFromUserRole']


class CandidateArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    include: 'CandidateIncludeFromCandidate'


class FindManyCandidateArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidate'


class JobIncludeFromUserRole(TypedDict, total=False):
    """Relational arguments for UserRole"""
    tenant: Union[bool, 'TenantArgsFromUserRole']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromUserRole']


class JobArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    include: 'JobIncludeFromJob'


class FindManyJobArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJob'


class JobCandidateIncludeFromUserRole(TypedDict, total=False):
    """Relational arguments for UserRole"""
    job: Union[bool, 'JobArgsFromUserRole']
    candidate: Union[bool, 'CandidateArgsFromUserRole']


class JobCandidateArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    include: 'JobCandidateIncludeFromJobCandidate'


class FindManyJobCandidateArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    take: int
    skip: int
    order_by: Union['JobCandidateOrderByInput', List['JobCandidateOrderByInput']]
    where: 'JobCandidateWhereInput'
    cursor: 'JobCandidateWhereUniqueInput'
    distinct: List['JobCandidateScalarFieldKeys']
    include: 'JobCandidateIncludeFromJobCandidate'


class ProjectIncludeFromUserRole(TypedDict, total=False):
    """Relational arguments for UserRole"""
    tenant: Union[bool, 'TenantArgsFromUserRole']
    user: Union[bool, 'UserArgsFromUserRole']


class ProjectArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    include: 'ProjectIncludeFromProject'


class FindManyProjectArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProject'


class AgentIncludeFromUserRole(TypedDict, total=False):
    """Relational arguments for UserRole"""
    tenant: Union[bool, 'TenantArgsFromUserRole']
    conversations: Union[bool, 'FindManyConversationArgsFromUserRole']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromUserRole']


class AgentArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    include: 'AgentIncludeFromAgent'


class FindManyAgentArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    take: int
    skip: int
    order_by: Union['AgentOrderByInput', List['AgentOrderByInput']]
    where: 'AgentWhereInput'
    cursor: 'AgentWhereUniqueInput'
    distinct: List['AgentScalarFieldKeys']
    include: 'AgentIncludeFromAgent'


class ConversationIncludeFromUserRole(TypedDict, total=False):
    """Relational arguments for UserRole"""
    agent: Union[bool, 'AgentArgsFromUserRole']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromUserRole']


class ConversationArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    include: 'ConversationIncludeFromConversation'


class FindManyConversationArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversation'


class AgentTaskIncludeFromUserRole(TypedDict, total=False):
    """Relational arguments for UserRole"""
    agent: Union[bool, 'AgentArgsFromUserRole']
    conversation: Union[bool, 'ConversationArgsFromUserRole']


class AgentTaskArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    include: 'AgentTaskIncludeFromAgentTask'


class FindManyAgentTaskArgsFromUserRole(TypedDict, total=False):
    """Arguments for UserRole"""
    take: int
    skip: int
    order_by: Union['AgentTaskOrderByInput', List['AgentTaskOrderByInput']]
    where: 'AgentTaskWhereInput'
    cursor: 'AgentTaskWhereUniqueInput'
    distinct: List['AgentTaskScalarFieldKeys']
    include: 'AgentTaskIncludeFromAgentTask'




FindManyUserRoleArgs = FindManyUserRoleArgsFromUserRole
FindFirstUserRoleArgs = FindManyUserRoleArgsFromUserRole


class UserRoleWhereInput(TypedDict, total=False):
    """UserRole arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    type: 'enums.UserRoleType'
    permissions: Union['fields.Json', 'types.JsonFilter']
    users: 'UserListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UserRoleWhereInput', List['UserRoleWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UserRoleWhereInput']
    OR: List['UserRoleWhereInput']
    NOT: List['UserRoleWhereInput']



# aggregate UserRole types


class UserRoleScalarWhereWithAggregatesInput(TypedDict, total=False):
    """UserRole arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.UserRoleType'
    permissions: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserRoleScalarWhereWithAggregatesInput']
    OR: List['UserRoleScalarWhereWithAggregatesInput']
    NOT: List['UserRoleScalarWhereWithAggregatesInput']



class UserRoleGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    type: 'enums.UserRoleType'
    permissions: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime
    _sum: 'UserRoleSumAggregateOutput'
    _avg: 'UserRoleAvgAggregateOutput'
    _min: 'UserRoleMinAggregateOutput'
    _max: 'UserRoleMaxAggregateOutput'
    _count: 'UserRoleCountAggregateOutput'


class UserRoleAvgAggregateOutput(TypedDict, total=False):
    """UserRole output for aggregating averages"""


class UserRoleSumAggregateOutput(TypedDict, total=False):
    """UserRole output for aggregating sums"""


class UserRoleScalarAggregateOutput(TypedDict, total=False):
    """UserRole output including scalar fields"""
    id: _str
    name: _str
    type: 'enums.UserRoleType'
    permissions: 'fields.Json'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime


UserRoleMinAggregateOutput = UserRoleScalarAggregateOutput
UserRoleMaxAggregateOutput = UserRoleScalarAggregateOutput


class UserRoleMaxAggregateInput(TypedDict, total=False):
    """UserRole input for aggregating by max"""
    id: bool
    name: bool
    type: bool
    permissions: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class UserRoleMinAggregateInput(TypedDict, total=False):
    """UserRole input for aggregating by min"""
    id: bool
    name: bool
    type: bool
    permissions: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class UserRoleNumberAggregateInput(TypedDict, total=False):
    """UserRole input for aggregating numbers"""


UserRoleAvgAggregateInput = UserRoleNumberAggregateInput
UserRoleSumAggregateInput = UserRoleNumberAggregateInput


UserRoleCountAggregateInput = TypedDict(
    'UserRoleCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'type': bool,
        'permissions': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deleted': bool,
        'deletedAt': bool,
        '_all': bool,
    },
    total=False,
)

UserRoleCountAggregateOutput = TypedDict(
    'UserRoleCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'type': int,
        'permissions': int,
        'createdAt': int,
        'updatedAt': int,
        'deleted': int,
        'deletedAt': int,
        '_all': int,
    },
    total=False,
)


UserRoleKeys = Literal[
    'id',
    'name',
    'type',
    'permissions',
    'users',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
UserRoleScalarFieldKeys = Literal[
    'id',
    'name',
    'type',
    'permissions',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
UserRoleScalarFieldKeysT = TypeVar('UserRoleScalarFieldKeysT', bound=UserRoleScalarFieldKeys)

UserRoleRelationalFieldKeys = Literal[
        'users',
    ]

# User types

class UserOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the User create method"""
    id: _str
    emailVerified: Optional[datetime.datetime]
    firstName: Optional[_str]
    lastName: Optional[_str]
    imageUrl: Optional[_str]
    passwordHash: Optional[_str]
    roleId: Optional[_str]
    role: 'UserRoleCreateNestedWithoutRelationsInput'
    tenantId: Optional[_str]
    tenant: 'TenantCreateNestedWithoutRelationsInput'
    projects: 'ProjectCreateManyNestedWithoutRelationsInput'
    sessions: 'UserSessionCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class UserCreateInput(UserOptionalCreateInput):
    """Required arguments to the User create method"""
    email: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the User create method, without relations"""
    id: _str
    emailVerified: Optional[datetime.datetime]
    firstName: Optional[_str]
    lastName: Optional[_str]
    imageUrl: Optional[_str]
    passwordHash: Optional[_str]
    roleId: Optional[_str]
    tenantId: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class UserCreateWithoutRelationsInput(UserOptionalCreateWithoutRelationsInput):
    """Required arguments to the User create method, without relations"""
    email: _str

class UserConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserCreateWithoutRelationsInput'
    where: 'UserWhereUniqueInput'

class UserCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'


class UserCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserCreateWithoutRelationsInput', List['UserCreateWithoutRelationsInput']]
    connect: Union['UserWhereUniqueInput', List['UserWhereUniqueInput']]
    connect_or_create: Union['UserConnectOrCreateWithoutRelationsInput', List['UserConnectOrCreateWithoutRelationsInput']]

_UserWhereUnique_id_Input = TypedDict(
    '_UserWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_UserWhereUnique_email_Input = TypedDict(
    '_UserWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

UserWhereUniqueInput = Union[
    '_UserWhereUnique_id_Input',
    '_UserWhereUnique_email_Input',
]


class UserUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    email: _str
    emailVerified: Optional[datetime.datetime]
    firstName: Optional[_str]
    lastName: Optional[_str]
    imageUrl: Optional[_str]
    passwordHash: Optional[_str]
    role: 'UserRoleUpdateOneWithoutRelationsInput'
    tenant: 'TenantUpdateOneWithoutRelationsInput'
    projects: 'ProjectUpdateManyWithoutRelationsInput'
    sessions: 'UserSessionUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class UserUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    email: _str
    emailVerified: Optional[datetime.datetime]
    firstName: Optional[_str]
    lastName: Optional[_str]
    imageUrl: Optional[_str]
    passwordHash: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class UserUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserCreateWithoutRelationsInput']
    connect: List['UserWhereUniqueInput']
    connect_or_create: List['UserConnectOrCreateWithoutRelationsInput']
    set: List['UserWhereUniqueInput']
    disconnect: List['UserWhereUniqueInput']
    delete: List['UserWhereUniqueInput']

    # TODO
    # update: List['UserUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserScalarWhereInput']
    # upsert: List['UserUpserteWithWhereUniqueWithoutRelationsInput']


class UserUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserCreateWithoutRelationsInput'
    connect: 'UserWhereUniqueInput'
    connect_or_create: 'UserConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserUpdateInput'
    # upsert: 'UserUpsertWithoutRelationsInput'


class UserUpsertInput(TypedDict):
    create: 'UserCreateInput'
    update: 'UserUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_User_id_OrderByInput = TypedDict(
    '_User_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_User_email_OrderByInput = TypedDict(
    '_User_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_User_emailVerified_OrderByInput = TypedDict(
    '_User_emailVerified_OrderByInput',
    {
        'emailVerified': 'SortOrder',
    },
    total=True
)

_User_firstName_OrderByInput = TypedDict(
    '_User_firstName_OrderByInput',
    {
        'firstName': 'SortOrder',
    },
    total=True
)

_User_lastName_OrderByInput = TypedDict(
    '_User_lastName_OrderByInput',
    {
        'lastName': 'SortOrder',
    },
    total=True
)

_User_imageUrl_OrderByInput = TypedDict(
    '_User_imageUrl_OrderByInput',
    {
        'imageUrl': 'SortOrder',
    },
    total=True
)

_User_passwordHash_OrderByInput = TypedDict(
    '_User_passwordHash_OrderByInput',
    {
        'passwordHash': 'SortOrder',
    },
    total=True
)

_User_roleId_OrderByInput = TypedDict(
    '_User_roleId_OrderByInput',
    {
        'roleId': 'SortOrder',
    },
    total=True
)

_User_tenantId_OrderByInput = TypedDict(
    '_User_tenantId_OrderByInput',
    {
        'tenantId': 'SortOrder',
    },
    total=True
)

_User_createdAt_OrderByInput = TypedDict(
    '_User_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_User_updatedAt_OrderByInput = TypedDict(
    '_User_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_User_deleted_OrderByInput = TypedDict(
    '_User_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_User_deletedAt_OrderByInput = TypedDict(
    '_User_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_User_RelevanceInner = TypedDict(
    '_User_RelevanceInner',
    {
        'fields': 'List[UserScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_User_RelevanceOrderByInput = TypedDict(
    '_User_RelevanceOrderByInput',
    {
        '_relevance': '_User_RelevanceInner',
    },
    total=True
)

UserOrderByInput = Union[
    '_User_id_OrderByInput',
    '_User_email_OrderByInput',
    '_User_emailVerified_OrderByInput',
    '_User_firstName_OrderByInput',
    '_User_lastName_OrderByInput',
    '_User_imageUrl_OrderByInput',
    '_User_passwordHash_OrderByInput',
    '_User_roleId_OrderByInput',
    '_User_tenantId_OrderByInput',
    '_User_createdAt_OrderByInput',
    '_User_updatedAt_OrderByInput',
    '_User_deleted_OrderByInput',
    '_User_deletedAt_OrderByInput',
    '_User_RelevanceOrderByInput',
]



# recursive User types
# TODO: cleanup these types



UserRelationFilter = TypedDict(
    'UserRelationFilter',
    {
        'is': 'UserWhereInput',
        'is_not': 'UserWhereInput',
    },
    total=False,
)


class UserListRelationFilter(TypedDict, total=False):
    some: 'UserWhereInput'
    none: 'UserWhereInput'
    every: 'UserWhereInput'


class UserInclude(TypedDict, total=False):
    """User relational arguments"""
    role: Union[bool, 'UserRoleArgsFromUser']
    tenant: Union[bool, 'TenantArgsFromUser']
    projects: Union[bool, 'FindManyProjectArgsFromUser']
    sessions: Union[bool, 'FindManyUserSessionArgsFromUser']


class LicenseIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tenants: Union[bool, 'FindManyTenantArgsFromUser']


class LicenseArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'LicenseIncludeFromLicense'


class FindManyLicenseArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['LicenseOrderByInput', List['LicenseOrderByInput']]
    where: 'LicenseWhereInput'
    cursor: 'LicenseWhereUniqueInput'
    distinct: List['LicenseScalarFieldKeys']
    include: 'LicenseIncludeFromLicense'


class TenantIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    users: Union[bool, 'FindManyUserArgsFromUser']
    projects: Union[bool, 'FindManyProjectArgsFromUser']
    jobs: Union[bool, 'FindManyJobArgsFromUser']
    agents: Union[bool, 'FindManyAgentArgsFromUser']
    candidates: Union[bool, 'FindManyCandidateArgsFromUser']
    license: Union[bool, 'LicenseArgsFromUser']


class TenantArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class UserRoleIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    users: Union[bool, 'FindManyUserArgsFromUser']


class UserRoleArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserRoleIncludeFromUserRole'


class FindManyUserRoleArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserRoleOrderByInput', List['UserRoleOrderByInput']]
    where: 'UserRoleWhereInput'
    cursor: 'UserRoleWhereUniqueInput'
    distinct: List['UserRoleScalarFieldKeys']
    include: 'UserRoleIncludeFromUserRole'


class UserIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    role: Union[bool, 'UserRoleArgsFromUser']
    tenant: Union[bool, 'TenantArgsFromUser']
    projects: Union[bool, 'FindManyProjectArgsFromUser']
    sessions: Union[bool, 'FindManyUserSessionArgsFromUser']


class UserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserSessionIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    user: Union[bool, 'UserArgsFromUser']


class UserSessionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'UserSessionIncludeFromUserSession'


class FindManyUserSessionArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['UserSessionOrderByInput', List['UserSessionOrderByInput']]
    where: 'UserSessionWhereInput'
    cursor: 'UserSessionWhereUniqueInput'
    distinct: List['UserSessionScalarFieldKeys']
    include: 'UserSessionIncludeFromUserSession'


class CandidateIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromUser']
    tenant: Union[bool, 'TenantArgsFromUser']


class CandidateArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'CandidateIncludeFromCandidate'


class FindManyCandidateArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidate'


class JobIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUser']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromUser']


class JobArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'JobIncludeFromJob'


class FindManyJobArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJob'


class JobCandidateIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    job: Union[bool, 'JobArgsFromUser']
    candidate: Union[bool, 'CandidateArgsFromUser']


class JobCandidateArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'JobCandidateIncludeFromJobCandidate'


class FindManyJobCandidateArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['JobCandidateOrderByInput', List['JobCandidateOrderByInput']]
    where: 'JobCandidateWhereInput'
    cursor: 'JobCandidateWhereUniqueInput'
    distinct: List['JobCandidateScalarFieldKeys']
    include: 'JobCandidateIncludeFromJobCandidate'


class ProjectIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUser']
    user: Union[bool, 'UserArgsFromUser']


class ProjectArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ProjectIncludeFromProject'


class FindManyProjectArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProject'


class AgentIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    tenant: Union[bool, 'TenantArgsFromUser']
    conversations: Union[bool, 'FindManyConversationArgsFromUser']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromUser']


class AgentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'AgentIncludeFromAgent'


class FindManyAgentArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AgentOrderByInput', List['AgentOrderByInput']]
    where: 'AgentWhereInput'
    cursor: 'AgentWhereUniqueInput'
    distinct: List['AgentScalarFieldKeys']
    include: 'AgentIncludeFromAgent'


class ConversationIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    agent: Union[bool, 'AgentArgsFromUser']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromUser']


class ConversationArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'ConversationIncludeFromConversation'


class FindManyConversationArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversation'


class AgentTaskIncludeFromUser(TypedDict, total=False):
    """Relational arguments for User"""
    agent: Union[bool, 'AgentArgsFromUser']
    conversation: Union[bool, 'ConversationArgsFromUser']


class AgentTaskArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    include: 'AgentTaskIncludeFromAgentTask'


class FindManyAgentTaskArgsFromUser(TypedDict, total=False):
    """Arguments for User"""
    take: int
    skip: int
    order_by: Union['AgentTaskOrderByInput', List['AgentTaskOrderByInput']]
    where: 'AgentTaskWhereInput'
    cursor: 'AgentTaskWhereUniqueInput'
    distinct: List['AgentTaskScalarFieldKeys']
    include: 'AgentTaskIncludeFromAgentTask'




FindManyUserArgs = FindManyUserArgsFromUser
FindFirstUserArgs = FindManyUserArgsFromUser


class UserWhereInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    emailVerified: Union[None, datetime.datetime, 'types.DateTimeFilter']
    firstName: Union[None, _str, 'types.StringFilter']
    lastName: Union[None, _str, 'types.StringFilter']
    imageUrl: Union[None, _str, 'types.StringFilter']
    passwordHash: Union[None, _str, 'types.StringFilter']
    roleId: Union[None, _str, 'types.StringFilter']
    role: 'UserRoleRelationFilter'
    tenantId: Union[None, _str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    projects: 'ProjectListRelationFilter'
    sessions: 'UserSessionListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UserWhereInput', List['UserWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UserWhereInput']
    OR: List['UserWhereInput']
    NOT: List['UserWhereInput']



# aggregate User types


class UserScalarWhereWithAggregatesInput(TypedDict, total=False):
    """User arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    emailVerified: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    firstName: Union[_str, 'types.StringWithAggregatesFilter']
    lastName: Union[_str, 'types.StringWithAggregatesFilter']
    imageUrl: Union[_str, 'types.StringWithAggregatesFilter']
    passwordHash: Union[_str, 'types.StringWithAggregatesFilter']
    roleId: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserScalarWhereWithAggregatesInput']
    OR: List['UserScalarWhereWithAggregatesInput']
    NOT: List['UserScalarWhereWithAggregatesInput']



class UserGroupByOutput(TypedDict, total=False):
    id: _str
    email: _str
    emailVerified: datetime.datetime
    firstName: _str
    lastName: _str
    imageUrl: _str
    passwordHash: _str
    roleId: _str
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime
    _sum: 'UserSumAggregateOutput'
    _avg: 'UserAvgAggregateOutput'
    _min: 'UserMinAggregateOutput'
    _max: 'UserMaxAggregateOutput'
    _count: 'UserCountAggregateOutput'


class UserAvgAggregateOutput(TypedDict, total=False):
    """User output for aggregating averages"""


class UserSumAggregateOutput(TypedDict, total=False):
    """User output for aggregating sums"""


class UserScalarAggregateOutput(TypedDict, total=False):
    """User output including scalar fields"""
    id: _str
    email: _str
    emailVerified: datetime.datetime
    firstName: _str
    lastName: _str
    imageUrl: _str
    passwordHash: _str
    roleId: _str
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime


UserMinAggregateOutput = UserScalarAggregateOutput
UserMaxAggregateOutput = UserScalarAggregateOutput


class UserMaxAggregateInput(TypedDict, total=False):
    """User input for aggregating by max"""
    id: bool
    email: bool
    emailVerified: bool
    firstName: bool
    lastName: bool
    imageUrl: bool
    passwordHash: bool
    roleId: bool
    tenantId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class UserMinAggregateInput(TypedDict, total=False):
    """User input for aggregating by min"""
    id: bool
    email: bool
    emailVerified: bool
    firstName: bool
    lastName: bool
    imageUrl: bool
    passwordHash: bool
    roleId: bool
    tenantId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class UserNumberAggregateInput(TypedDict, total=False):
    """User input for aggregating numbers"""


UserAvgAggregateInput = UserNumberAggregateInput
UserSumAggregateInput = UserNumberAggregateInput


UserCountAggregateInput = TypedDict(
    'UserCountAggregateInput',
    {
        'id': bool,
        'email': bool,
        'emailVerified': bool,
        'firstName': bool,
        'lastName': bool,
        'imageUrl': bool,
        'passwordHash': bool,
        'roleId': bool,
        'tenantId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deleted': bool,
        'deletedAt': bool,
        '_all': bool,
    },
    total=False,
)

UserCountAggregateOutput = TypedDict(
    'UserCountAggregateOutput',
    {
        'id': int,
        'email': int,
        'emailVerified': int,
        'firstName': int,
        'lastName': int,
        'imageUrl': int,
        'passwordHash': int,
        'roleId': int,
        'tenantId': int,
        'createdAt': int,
        'updatedAt': int,
        'deleted': int,
        'deletedAt': int,
        '_all': int,
    },
    total=False,
)


UserKeys = Literal[
    'id',
    'email',
    'emailVerified',
    'firstName',
    'lastName',
    'imageUrl',
    'passwordHash',
    'roleId',
    'role',
    'tenantId',
    'tenant',
    'projects',
    'sessions',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
UserScalarFieldKeys = Literal[
    'id',
    'email',
    'emailVerified',
    'firstName',
    'lastName',
    'imageUrl',
    'passwordHash',
    'roleId',
    'tenantId',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
UserScalarFieldKeysT = TypeVar('UserScalarFieldKeysT', bound=UserScalarFieldKeys)

UserRelationalFieldKeys = Literal[
        'role',
        'tenant',
        'projects',
        'sessions',
    ]

# UserSession types

class UserSessionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the UserSession create method"""
    id: _str
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    ipAddress: Optional[_str]
    userAgent: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class UserSessionCreateInput(UserSessionOptionalCreateInput):
    """Required arguments to the UserSession create method"""
    token: _str
    expiresAt: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserSessionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the UserSession create method, without relations"""
    id: _str
    userId: _str
    ipAddress: Optional[_str]
    userAgent: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class UserSessionCreateWithoutRelationsInput(UserSessionOptionalCreateWithoutRelationsInput):
    """Required arguments to the UserSession create method, without relations"""
    token: _str
    expiresAt: datetime.datetime

class UserSessionConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'UserSessionCreateWithoutRelationsInput'
    where: 'UserSessionWhereUniqueInput'

class UserSessionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserSessionCreateWithoutRelationsInput'
    connect: 'UserSessionWhereUniqueInput'
    connect_or_create: 'UserSessionConnectOrCreateWithoutRelationsInput'


class UserSessionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserSessionCreateWithoutRelationsInput', List['UserSessionCreateWithoutRelationsInput']]
    connect: Union['UserSessionWhereUniqueInput', List['UserSessionWhereUniqueInput']]
    connect_or_create: Union['UserSessionConnectOrCreateWithoutRelationsInput', List['UserSessionConnectOrCreateWithoutRelationsInput']]

_UserSessionWhereUnique_id_Input = TypedDict(
    '_UserSessionWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_UserSessionWhereUnique_token_Input = TypedDict(
    '_UserSessionWhereUnique_token_Input',
    {
        'token': '_str',
    },
    total=True
)

UserSessionWhereUniqueInput = Union[
    '_UserSessionWhereUnique_id_Input',
    '_UserSessionWhereUnique_token_Input',
]


class UserSessionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    user: 'UserUpdateOneWithoutRelationsInput'
    token: _str
    expiresAt: datetime.datetime
    ipAddress: Optional[_str]
    userAgent: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class UserSessionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    token: _str
    expiresAt: datetime.datetime
    ipAddress: Optional[_str]
    userAgent: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class UserSessionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserSessionCreateWithoutRelationsInput']
    connect: List['UserSessionWhereUniqueInput']
    connect_or_create: List['UserSessionConnectOrCreateWithoutRelationsInput']
    set: List['UserSessionWhereUniqueInput']
    disconnect: List['UserSessionWhereUniqueInput']
    delete: List['UserSessionWhereUniqueInput']

    # TODO
    # update: List['UserSessionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserSessionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserSessionScalarWhereInput']
    # upsert: List['UserSessionUpserteWithWhereUniqueWithoutRelationsInput']


class UserSessionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserSessionCreateWithoutRelationsInput'
    connect: 'UserSessionWhereUniqueInput'
    connect_or_create: 'UserSessionConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserSessionUpdateInput'
    # upsert: 'UserSessionUpsertWithoutRelationsInput'


class UserSessionUpsertInput(TypedDict):
    create: 'UserSessionCreateInput'
    update: 'UserSessionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_UserSession_id_OrderByInput = TypedDict(
    '_UserSession_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_UserSession_userId_OrderByInput = TypedDict(
    '_UserSession_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_UserSession_token_OrderByInput = TypedDict(
    '_UserSession_token_OrderByInput',
    {
        'token': 'SortOrder',
    },
    total=True
)

_UserSession_expiresAt_OrderByInput = TypedDict(
    '_UserSession_expiresAt_OrderByInput',
    {
        'expiresAt': 'SortOrder',
    },
    total=True
)

_UserSession_ipAddress_OrderByInput = TypedDict(
    '_UserSession_ipAddress_OrderByInput',
    {
        'ipAddress': 'SortOrder',
    },
    total=True
)

_UserSession_userAgent_OrderByInput = TypedDict(
    '_UserSession_userAgent_OrderByInput',
    {
        'userAgent': 'SortOrder',
    },
    total=True
)

_UserSession_createdAt_OrderByInput = TypedDict(
    '_UserSession_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_UserSession_updatedAt_OrderByInput = TypedDict(
    '_UserSession_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_UserSession_deleted_OrderByInput = TypedDict(
    '_UserSession_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_UserSession_deletedAt_OrderByInput = TypedDict(
    '_UserSession_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_UserSession_RelevanceInner = TypedDict(
    '_UserSession_RelevanceInner',
    {
        'fields': 'List[UserSessionScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_UserSession_RelevanceOrderByInput = TypedDict(
    '_UserSession_RelevanceOrderByInput',
    {
        '_relevance': '_UserSession_RelevanceInner',
    },
    total=True
)

UserSessionOrderByInput = Union[
    '_UserSession_id_OrderByInput',
    '_UserSession_userId_OrderByInput',
    '_UserSession_token_OrderByInput',
    '_UserSession_expiresAt_OrderByInput',
    '_UserSession_ipAddress_OrderByInput',
    '_UserSession_userAgent_OrderByInput',
    '_UserSession_createdAt_OrderByInput',
    '_UserSession_updatedAt_OrderByInput',
    '_UserSession_deleted_OrderByInput',
    '_UserSession_deletedAt_OrderByInput',
    '_UserSession_RelevanceOrderByInput',
]



# recursive UserSession types
# TODO: cleanup these types



UserSessionRelationFilter = TypedDict(
    'UserSessionRelationFilter',
    {
        'is': 'UserSessionWhereInput',
        'is_not': 'UserSessionWhereInput',
    },
    total=False,
)


class UserSessionListRelationFilter(TypedDict, total=False):
    some: 'UserSessionWhereInput'
    none: 'UserSessionWhereInput'
    every: 'UserSessionWhereInput'


class UserSessionInclude(TypedDict, total=False):
    """UserSession relational arguments"""
    user: Union[bool, 'UserArgsFromUserSession']


class LicenseIncludeFromUserSession(TypedDict, total=False):
    """Relational arguments for UserSession"""
    tenants: Union[bool, 'FindManyTenantArgsFromUserSession']


class LicenseArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    include: 'LicenseIncludeFromLicense'


class FindManyLicenseArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    take: int
    skip: int
    order_by: Union['LicenseOrderByInput', List['LicenseOrderByInput']]
    where: 'LicenseWhereInput'
    cursor: 'LicenseWhereUniqueInput'
    distinct: List['LicenseScalarFieldKeys']
    include: 'LicenseIncludeFromLicense'


class TenantIncludeFromUserSession(TypedDict, total=False):
    """Relational arguments for UserSession"""
    users: Union[bool, 'FindManyUserArgsFromUserSession']
    projects: Union[bool, 'FindManyProjectArgsFromUserSession']
    jobs: Union[bool, 'FindManyJobArgsFromUserSession']
    agents: Union[bool, 'FindManyAgentArgsFromUserSession']
    candidates: Union[bool, 'FindManyCandidateArgsFromUserSession']
    license: Union[bool, 'LicenseArgsFromUserSession']


class TenantArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class UserRoleIncludeFromUserSession(TypedDict, total=False):
    """Relational arguments for UserSession"""
    users: Union[bool, 'FindManyUserArgsFromUserSession']


class UserRoleArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    include: 'UserRoleIncludeFromUserRole'


class FindManyUserRoleArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    take: int
    skip: int
    order_by: Union['UserRoleOrderByInput', List['UserRoleOrderByInput']]
    where: 'UserRoleWhereInput'
    cursor: 'UserRoleWhereUniqueInput'
    distinct: List['UserRoleScalarFieldKeys']
    include: 'UserRoleIncludeFromUserRole'


class UserIncludeFromUserSession(TypedDict, total=False):
    """Relational arguments for UserSession"""
    role: Union[bool, 'UserRoleArgsFromUserSession']
    tenant: Union[bool, 'TenantArgsFromUserSession']
    projects: Union[bool, 'FindManyProjectArgsFromUserSession']
    sessions: Union[bool, 'FindManyUserSessionArgsFromUserSession']


class UserArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserSessionIncludeFromUserSession(TypedDict, total=False):
    """Relational arguments for UserSession"""
    user: Union[bool, 'UserArgsFromUserSession']


class UserSessionArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    include: 'UserSessionIncludeFromUserSession'


class FindManyUserSessionArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    take: int
    skip: int
    order_by: Union['UserSessionOrderByInput', List['UserSessionOrderByInput']]
    where: 'UserSessionWhereInput'
    cursor: 'UserSessionWhereUniqueInput'
    distinct: List['UserSessionScalarFieldKeys']
    include: 'UserSessionIncludeFromUserSession'


class CandidateIncludeFromUserSession(TypedDict, total=False):
    """Relational arguments for UserSession"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromUserSession']
    tenant: Union[bool, 'TenantArgsFromUserSession']


class CandidateArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    include: 'CandidateIncludeFromCandidate'


class FindManyCandidateArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidate'


class JobIncludeFromUserSession(TypedDict, total=False):
    """Relational arguments for UserSession"""
    tenant: Union[bool, 'TenantArgsFromUserSession']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromUserSession']


class JobArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    include: 'JobIncludeFromJob'


class FindManyJobArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJob'


class JobCandidateIncludeFromUserSession(TypedDict, total=False):
    """Relational arguments for UserSession"""
    job: Union[bool, 'JobArgsFromUserSession']
    candidate: Union[bool, 'CandidateArgsFromUserSession']


class JobCandidateArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    include: 'JobCandidateIncludeFromJobCandidate'


class FindManyJobCandidateArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    take: int
    skip: int
    order_by: Union['JobCandidateOrderByInput', List['JobCandidateOrderByInput']]
    where: 'JobCandidateWhereInput'
    cursor: 'JobCandidateWhereUniqueInput'
    distinct: List['JobCandidateScalarFieldKeys']
    include: 'JobCandidateIncludeFromJobCandidate'


class ProjectIncludeFromUserSession(TypedDict, total=False):
    """Relational arguments for UserSession"""
    tenant: Union[bool, 'TenantArgsFromUserSession']
    user: Union[bool, 'UserArgsFromUserSession']


class ProjectArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    include: 'ProjectIncludeFromProject'


class FindManyProjectArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProject'


class AgentIncludeFromUserSession(TypedDict, total=False):
    """Relational arguments for UserSession"""
    tenant: Union[bool, 'TenantArgsFromUserSession']
    conversations: Union[bool, 'FindManyConversationArgsFromUserSession']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromUserSession']


class AgentArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    include: 'AgentIncludeFromAgent'


class FindManyAgentArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    take: int
    skip: int
    order_by: Union['AgentOrderByInput', List['AgentOrderByInput']]
    where: 'AgentWhereInput'
    cursor: 'AgentWhereUniqueInput'
    distinct: List['AgentScalarFieldKeys']
    include: 'AgentIncludeFromAgent'


class ConversationIncludeFromUserSession(TypedDict, total=False):
    """Relational arguments for UserSession"""
    agent: Union[bool, 'AgentArgsFromUserSession']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromUserSession']


class ConversationArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    include: 'ConversationIncludeFromConversation'


class FindManyConversationArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversation'


class AgentTaskIncludeFromUserSession(TypedDict, total=False):
    """Relational arguments for UserSession"""
    agent: Union[bool, 'AgentArgsFromUserSession']
    conversation: Union[bool, 'ConversationArgsFromUserSession']


class AgentTaskArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    include: 'AgentTaskIncludeFromAgentTask'


class FindManyAgentTaskArgsFromUserSession(TypedDict, total=False):
    """Arguments for UserSession"""
    take: int
    skip: int
    order_by: Union['AgentTaskOrderByInput', List['AgentTaskOrderByInput']]
    where: 'AgentTaskWhereInput'
    cursor: 'AgentTaskWhereUniqueInput'
    distinct: List['AgentTaskScalarFieldKeys']
    include: 'AgentTaskIncludeFromAgentTask'




FindManyUserSessionArgs = FindManyUserSessionArgsFromUserSession
FindFirstUserSessionArgs = FindManyUserSessionArgsFromUserSession


class UserSessionWhereInput(TypedDict, total=False):
    """UserSession arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    token: Union[_str, 'types.StringFilter']
    expiresAt: Union[datetime.datetime, 'types.DateTimeFilter']
    ipAddress: Union[None, _str, 'types.StringFilter']
    userAgent: Union[None, _str, 'types.StringFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['UserSessionWhereInput', List['UserSessionWhereInput']]
    # but this causes mypy to hang :/
    AND: List['UserSessionWhereInput']
    OR: List['UserSessionWhereInput']
    NOT: List['UserSessionWhereInput']



# aggregate UserSession types


class UserSessionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """UserSession arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    token: Union[_str, 'types.StringWithAggregatesFilter']
    expiresAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    ipAddress: Union[_str, 'types.StringWithAggregatesFilter']
    userAgent: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserSessionScalarWhereWithAggregatesInput']
    OR: List['UserSessionScalarWhereWithAggregatesInput']
    NOT: List['UserSessionScalarWhereWithAggregatesInput']



class UserSessionGroupByOutput(TypedDict, total=False):
    id: _str
    userId: _str
    token: _str
    expiresAt: datetime.datetime
    ipAddress: _str
    userAgent: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime
    _sum: 'UserSessionSumAggregateOutput'
    _avg: 'UserSessionAvgAggregateOutput'
    _min: 'UserSessionMinAggregateOutput'
    _max: 'UserSessionMaxAggregateOutput'
    _count: 'UserSessionCountAggregateOutput'


class UserSessionAvgAggregateOutput(TypedDict, total=False):
    """UserSession output for aggregating averages"""


class UserSessionSumAggregateOutput(TypedDict, total=False):
    """UserSession output for aggregating sums"""


class UserSessionScalarAggregateOutput(TypedDict, total=False):
    """UserSession output including scalar fields"""
    id: _str
    userId: _str
    token: _str
    expiresAt: datetime.datetime
    ipAddress: _str
    userAgent: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime


UserSessionMinAggregateOutput = UserSessionScalarAggregateOutput
UserSessionMaxAggregateOutput = UserSessionScalarAggregateOutput


class UserSessionMaxAggregateInput(TypedDict, total=False):
    """UserSession input for aggregating by max"""
    id: bool
    userId: bool
    token: bool
    expiresAt: bool
    ipAddress: bool
    userAgent: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class UserSessionMinAggregateInput(TypedDict, total=False):
    """UserSession input for aggregating by min"""
    id: bool
    userId: bool
    token: bool
    expiresAt: bool
    ipAddress: bool
    userAgent: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class UserSessionNumberAggregateInput(TypedDict, total=False):
    """UserSession input for aggregating numbers"""


UserSessionAvgAggregateInput = UserSessionNumberAggregateInput
UserSessionSumAggregateInput = UserSessionNumberAggregateInput


UserSessionCountAggregateInput = TypedDict(
    'UserSessionCountAggregateInput',
    {
        'id': bool,
        'userId': bool,
        'token': bool,
        'expiresAt': bool,
        'ipAddress': bool,
        'userAgent': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deleted': bool,
        'deletedAt': bool,
        '_all': bool,
    },
    total=False,
)

UserSessionCountAggregateOutput = TypedDict(
    'UserSessionCountAggregateOutput',
    {
        'id': int,
        'userId': int,
        'token': int,
        'expiresAt': int,
        'ipAddress': int,
        'userAgent': int,
        'createdAt': int,
        'updatedAt': int,
        'deleted': int,
        'deletedAt': int,
        '_all': int,
    },
    total=False,
)


UserSessionKeys = Literal[
    'id',
    'userId',
    'user',
    'token',
    'expiresAt',
    'ipAddress',
    'userAgent',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
UserSessionScalarFieldKeys = Literal[
    'id',
    'userId',
    'token',
    'expiresAt',
    'ipAddress',
    'userAgent',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
UserSessionScalarFieldKeysT = TypeVar('UserSessionScalarFieldKeysT', bound=UserSessionScalarFieldKeys)

UserSessionRelationalFieldKeys = Literal[
        'user',
    ]

# Candidate types

class CandidateOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Candidate create method"""
    id: _str
    phone: Optional[_str]
    resumeUrl: Optional[_str]
    linkedinUrl: Optional[_str]
    currentTitle: Optional[_str]
    currentCompany: Optional[_str]
    careerLevel: 'enums.CareerLevel'
    yearsOfExperience: Optional[_int]
    skills: List[_str]
    languages: List[_str]
    location: Optional[_str]
    currentSalary: Optional[_float]
    expectedSalary: Optional[_float]
    currency: Optional[_str]
    noticePeriod: Optional[_int]
    noticePeriodUnit: Optional[_str]
    visaStatus: Optional[_str]
    immigrationStatus: Optional[_str]
    immigrationCountry: Optional[_str]
    status: 'enums.CandidateStatus'
    source: 'enums.CandidateSource'
    notes: Optional[_str]
    jobCandidates: 'JobCandidateCreateManyNestedWithoutRelationsInput'
    tenantId: Optional[_str]
    tenant: 'TenantCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class CandidateCreateInput(CandidateOptionalCreateInput):
    """Required arguments to the Candidate create method"""
    firstName: _str
    lastName: _str
    email: _str
    educationLevel: 'enums.EducationLevel'


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class CandidateOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Candidate create method, without relations"""
    id: _str
    phone: Optional[_str]
    resumeUrl: Optional[_str]
    linkedinUrl: Optional[_str]
    currentTitle: Optional[_str]
    currentCompany: Optional[_str]
    careerLevel: 'enums.CareerLevel'
    yearsOfExperience: Optional[_int]
    skills: List[_str]
    languages: List[_str]
    location: Optional[_str]
    currentSalary: Optional[_float]
    expectedSalary: Optional[_float]
    currency: Optional[_str]
    noticePeriod: Optional[_int]
    noticePeriodUnit: Optional[_str]
    visaStatus: Optional[_str]
    immigrationStatus: Optional[_str]
    immigrationCountry: Optional[_str]
    status: 'enums.CandidateStatus'
    source: 'enums.CandidateSource'
    notes: Optional[_str]
    tenantId: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class CandidateCreateWithoutRelationsInput(CandidateOptionalCreateWithoutRelationsInput):
    """Required arguments to the Candidate create method, without relations"""
    firstName: _str
    lastName: _str
    email: _str
    educationLevel: 'enums.EducationLevel'

class CandidateConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'CandidateCreateWithoutRelationsInput'
    where: 'CandidateWhereUniqueInput'

class CandidateCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'CandidateCreateWithoutRelationsInput'
    connect: 'CandidateWhereUniqueInput'
    connect_or_create: 'CandidateConnectOrCreateWithoutRelationsInput'


class CandidateCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['CandidateCreateWithoutRelationsInput', List['CandidateCreateWithoutRelationsInput']]
    connect: Union['CandidateWhereUniqueInput', List['CandidateWhereUniqueInput']]
    connect_or_create: Union['CandidateConnectOrCreateWithoutRelationsInput', List['CandidateConnectOrCreateWithoutRelationsInput']]

_CandidateWhereUnique_id_Input = TypedDict(
    '_CandidateWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_CandidateWhereUnique_email_Input = TypedDict(
    '_CandidateWhereUnique_email_Input',
    {
        'email': '_str',
    },
    total=True
)

CandidateWhereUniqueInput = Union[
    '_CandidateWhereUnique_id_Input',
    '_CandidateWhereUnique_email_Input',
]


class CandidateUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    firstName: _str
    lastName: _str
    email: _str
    phone: Optional[_str]
    resumeUrl: Optional[_str]
    linkedinUrl: Optional[_str]
    currentTitle: Optional[_str]
    currentCompany: Optional[_str]
    careerLevel: 'enums.CareerLevel'
    yearsOfExperience: Optional[Union[AtomicIntInput, _int]]
    educationLevel: 'enums.EducationLevel'
    skills: 'types.StringListUpdate'
    languages: 'types.StringListUpdate'
    location: Optional[_str]
    currentSalary: Optional[Union[AtomicFloatInput, _float]]
    expectedSalary: Optional[Union[AtomicFloatInput, _float]]
    currency: Optional[_str]
    noticePeriod: Optional[Union[AtomicIntInput, _int]]
    noticePeriodUnit: Optional[_str]
    visaStatus: Optional[_str]
    immigrationStatus: Optional[_str]
    immigrationCountry: Optional[_str]
    status: 'enums.CandidateStatus'
    source: 'enums.CandidateSource'
    notes: Optional[_str]
    jobCandidates: 'JobCandidateUpdateManyWithoutRelationsInput'
    tenant: 'TenantUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class CandidateUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    firstName: _str
    lastName: _str
    email: _str
    phone: Optional[_str]
    resumeUrl: Optional[_str]
    linkedinUrl: Optional[_str]
    currentTitle: Optional[_str]
    currentCompany: Optional[_str]
    careerLevel: 'enums.CareerLevel'
    yearsOfExperience: Optional[Union[AtomicIntInput, _int]]
    educationLevel: 'enums.EducationLevel'
    skills: 'types.StringListUpdate'
    languages: 'types.StringListUpdate'
    location: Optional[_str]
    currentSalary: Optional[Union[AtomicFloatInput, _float]]
    expectedSalary: Optional[Union[AtomicFloatInput, _float]]
    currency: Optional[_str]
    noticePeriod: Optional[Union[AtomicIntInput, _int]]
    noticePeriodUnit: Optional[_str]
    visaStatus: Optional[_str]
    immigrationStatus: Optional[_str]
    immigrationCountry: Optional[_str]
    status: 'enums.CandidateStatus'
    source: 'enums.CandidateSource'
    notes: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class CandidateUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['CandidateCreateWithoutRelationsInput']
    connect: List['CandidateWhereUniqueInput']
    connect_or_create: List['CandidateConnectOrCreateWithoutRelationsInput']
    set: List['CandidateWhereUniqueInput']
    disconnect: List['CandidateWhereUniqueInput']
    delete: List['CandidateWhereUniqueInput']

    # TODO
    # update: List['CandidateUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['CandidateUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['CandidateScalarWhereInput']
    # upsert: List['CandidateUpserteWithWhereUniqueWithoutRelationsInput']


class CandidateUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'CandidateCreateWithoutRelationsInput'
    connect: 'CandidateWhereUniqueInput'
    connect_or_create: 'CandidateConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'CandidateUpdateInput'
    # upsert: 'CandidateUpsertWithoutRelationsInput'


class CandidateUpsertInput(TypedDict):
    create: 'CandidateCreateInput'
    update: 'CandidateUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Candidate_id_OrderByInput = TypedDict(
    '_Candidate_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Candidate_firstName_OrderByInput = TypedDict(
    '_Candidate_firstName_OrderByInput',
    {
        'firstName': 'SortOrder',
    },
    total=True
)

_Candidate_lastName_OrderByInput = TypedDict(
    '_Candidate_lastName_OrderByInput',
    {
        'lastName': 'SortOrder',
    },
    total=True
)

_Candidate_email_OrderByInput = TypedDict(
    '_Candidate_email_OrderByInput',
    {
        'email': 'SortOrder',
    },
    total=True
)

_Candidate_phone_OrderByInput = TypedDict(
    '_Candidate_phone_OrderByInput',
    {
        'phone': 'SortOrder',
    },
    total=True
)

_Candidate_resumeUrl_OrderByInput = TypedDict(
    '_Candidate_resumeUrl_OrderByInput',
    {
        'resumeUrl': 'SortOrder',
    },
    total=True
)

_Candidate_linkedinUrl_OrderByInput = TypedDict(
    '_Candidate_linkedinUrl_OrderByInput',
    {
        'linkedinUrl': 'SortOrder',
    },
    total=True
)

_Candidate_currentTitle_OrderByInput = TypedDict(
    '_Candidate_currentTitle_OrderByInput',
    {
        'currentTitle': 'SortOrder',
    },
    total=True
)

_Candidate_currentCompany_OrderByInput = TypedDict(
    '_Candidate_currentCompany_OrderByInput',
    {
        'currentCompany': 'SortOrder',
    },
    total=True
)

_Candidate_careerLevel_OrderByInput = TypedDict(
    '_Candidate_careerLevel_OrderByInput',
    {
        'careerLevel': 'SortOrder',
    },
    total=True
)

_Candidate_yearsOfExperience_OrderByInput = TypedDict(
    '_Candidate_yearsOfExperience_OrderByInput',
    {
        'yearsOfExperience': 'SortOrder',
    },
    total=True
)

_Candidate_educationLevel_OrderByInput = TypedDict(
    '_Candidate_educationLevel_OrderByInput',
    {
        'educationLevel': 'SortOrder',
    },
    total=True
)

_Candidate_skills_OrderByInput = TypedDict(
    '_Candidate_skills_OrderByInput',
    {
        'skills': 'SortOrder',
    },
    total=True
)

_Candidate_languages_OrderByInput = TypedDict(
    '_Candidate_languages_OrderByInput',
    {
        'languages': 'SortOrder',
    },
    total=True
)

_Candidate_location_OrderByInput = TypedDict(
    '_Candidate_location_OrderByInput',
    {
        'location': 'SortOrder',
    },
    total=True
)

_Candidate_currentSalary_OrderByInput = TypedDict(
    '_Candidate_currentSalary_OrderByInput',
    {
        'currentSalary': 'SortOrder',
    },
    total=True
)

_Candidate_expectedSalary_OrderByInput = TypedDict(
    '_Candidate_expectedSalary_OrderByInput',
    {
        'expectedSalary': 'SortOrder',
    },
    total=True
)

_Candidate_currency_OrderByInput = TypedDict(
    '_Candidate_currency_OrderByInput',
    {
        'currency': 'SortOrder',
    },
    total=True
)

_Candidate_noticePeriod_OrderByInput = TypedDict(
    '_Candidate_noticePeriod_OrderByInput',
    {
        'noticePeriod': 'SortOrder',
    },
    total=True
)

_Candidate_noticePeriodUnit_OrderByInput = TypedDict(
    '_Candidate_noticePeriodUnit_OrderByInput',
    {
        'noticePeriodUnit': 'SortOrder',
    },
    total=True
)

_Candidate_visaStatus_OrderByInput = TypedDict(
    '_Candidate_visaStatus_OrderByInput',
    {
        'visaStatus': 'SortOrder',
    },
    total=True
)

_Candidate_immigrationStatus_OrderByInput = TypedDict(
    '_Candidate_immigrationStatus_OrderByInput',
    {
        'immigrationStatus': 'SortOrder',
    },
    total=True
)

_Candidate_immigrationCountry_OrderByInput = TypedDict(
    '_Candidate_immigrationCountry_OrderByInput',
    {
        'immigrationCountry': 'SortOrder',
    },
    total=True
)

_Candidate_status_OrderByInput = TypedDict(
    '_Candidate_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Candidate_source_OrderByInput = TypedDict(
    '_Candidate_source_OrderByInput',
    {
        'source': 'SortOrder',
    },
    total=True
)

_Candidate_notes_OrderByInput = TypedDict(
    '_Candidate_notes_OrderByInput',
    {
        'notes': 'SortOrder',
    },
    total=True
)

_Candidate_tenantId_OrderByInput = TypedDict(
    '_Candidate_tenantId_OrderByInput',
    {
        'tenantId': 'SortOrder',
    },
    total=True
)

_Candidate_createdAt_OrderByInput = TypedDict(
    '_Candidate_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Candidate_updatedAt_OrderByInput = TypedDict(
    '_Candidate_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Candidate_deleted_OrderByInput = TypedDict(
    '_Candidate_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_Candidate_deletedAt_OrderByInput = TypedDict(
    '_Candidate_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_Candidate_RelevanceInner = TypedDict(
    '_Candidate_RelevanceInner',
    {
        'fields': 'List[CandidateScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Candidate_RelevanceOrderByInput = TypedDict(
    '_Candidate_RelevanceOrderByInput',
    {
        '_relevance': '_Candidate_RelevanceInner',
    },
    total=True
)

CandidateOrderByInput = Union[
    '_Candidate_id_OrderByInput',
    '_Candidate_firstName_OrderByInput',
    '_Candidate_lastName_OrderByInput',
    '_Candidate_email_OrderByInput',
    '_Candidate_phone_OrderByInput',
    '_Candidate_resumeUrl_OrderByInput',
    '_Candidate_linkedinUrl_OrderByInput',
    '_Candidate_currentTitle_OrderByInput',
    '_Candidate_currentCompany_OrderByInput',
    '_Candidate_careerLevel_OrderByInput',
    '_Candidate_yearsOfExperience_OrderByInput',
    '_Candidate_educationLevel_OrderByInput',
    '_Candidate_skills_OrderByInput',
    '_Candidate_languages_OrderByInput',
    '_Candidate_location_OrderByInput',
    '_Candidate_currentSalary_OrderByInput',
    '_Candidate_expectedSalary_OrderByInput',
    '_Candidate_currency_OrderByInput',
    '_Candidate_noticePeriod_OrderByInput',
    '_Candidate_noticePeriodUnit_OrderByInput',
    '_Candidate_visaStatus_OrderByInput',
    '_Candidate_immigrationStatus_OrderByInput',
    '_Candidate_immigrationCountry_OrderByInput',
    '_Candidate_status_OrderByInput',
    '_Candidate_source_OrderByInput',
    '_Candidate_notes_OrderByInput',
    '_Candidate_tenantId_OrderByInput',
    '_Candidate_createdAt_OrderByInput',
    '_Candidate_updatedAt_OrderByInput',
    '_Candidate_deleted_OrderByInput',
    '_Candidate_deletedAt_OrderByInput',
    '_Candidate_RelevanceOrderByInput',
]



# recursive Candidate types
# TODO: cleanup these types



CandidateRelationFilter = TypedDict(
    'CandidateRelationFilter',
    {
        'is': 'CandidateWhereInput',
        'is_not': 'CandidateWhereInput',
    },
    total=False,
)


class CandidateListRelationFilter(TypedDict, total=False):
    some: 'CandidateWhereInput'
    none: 'CandidateWhereInput'
    every: 'CandidateWhereInput'


class CandidateInclude(TypedDict, total=False):
    """Candidate relational arguments"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromCandidate']
    tenant: Union[bool, 'TenantArgsFromCandidate']


class LicenseIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenants: Union[bool, 'FindManyTenantArgsFromCandidate']


class LicenseArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'LicenseIncludeFromLicense'


class FindManyLicenseArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['LicenseOrderByInput', List['LicenseOrderByInput']]
    where: 'LicenseWhereInput'
    cursor: 'LicenseWhereUniqueInput'
    distinct: List['LicenseScalarFieldKeys']
    include: 'LicenseIncludeFromLicense'


class TenantIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    users: Union[bool, 'FindManyUserArgsFromCandidate']
    projects: Union[bool, 'FindManyProjectArgsFromCandidate']
    jobs: Union[bool, 'FindManyJobArgsFromCandidate']
    agents: Union[bool, 'FindManyAgentArgsFromCandidate']
    candidates: Union[bool, 'FindManyCandidateArgsFromCandidate']
    license: Union[bool, 'LicenseArgsFromCandidate']


class TenantArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class UserRoleIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    users: Union[bool, 'FindManyUserArgsFromCandidate']


class UserRoleArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'UserRoleIncludeFromUserRole'


class FindManyUserRoleArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['UserRoleOrderByInput', List['UserRoleOrderByInput']]
    where: 'UserRoleWhereInput'
    cursor: 'UserRoleWhereUniqueInput'
    distinct: List['UserRoleScalarFieldKeys']
    include: 'UserRoleIncludeFromUserRole'


class UserIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    role: Union[bool, 'UserRoleArgsFromCandidate']
    tenant: Union[bool, 'TenantArgsFromCandidate']
    projects: Union[bool, 'FindManyProjectArgsFromCandidate']
    sessions: Union[bool, 'FindManyUserSessionArgsFromCandidate']


class UserArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserSessionIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    user: Union[bool, 'UserArgsFromCandidate']


class UserSessionArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'UserSessionIncludeFromUserSession'


class FindManyUserSessionArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['UserSessionOrderByInput', List['UserSessionOrderByInput']]
    where: 'UserSessionWhereInput'
    cursor: 'UserSessionWhereUniqueInput'
    distinct: List['UserSessionScalarFieldKeys']
    include: 'UserSessionIncludeFromUserSession'


class CandidateIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromCandidate']
    tenant: Union[bool, 'TenantArgsFromCandidate']


class CandidateArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'CandidateIncludeFromCandidate'


class FindManyCandidateArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidate'


class JobIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidate']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromCandidate']


class JobArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'JobIncludeFromJob'


class FindManyJobArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJob'


class JobCandidateIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    job: Union[bool, 'JobArgsFromCandidate']
    candidate: Union[bool, 'CandidateArgsFromCandidate']


class JobCandidateArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'JobCandidateIncludeFromJobCandidate'


class FindManyJobCandidateArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['JobCandidateOrderByInput', List['JobCandidateOrderByInput']]
    where: 'JobCandidateWhereInput'
    cursor: 'JobCandidateWhereUniqueInput'
    distinct: List['JobCandidateScalarFieldKeys']
    include: 'JobCandidateIncludeFromJobCandidate'


class ProjectIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidate']
    user: Union[bool, 'UserArgsFromCandidate']


class ProjectArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'ProjectIncludeFromProject'


class FindManyProjectArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProject'


class AgentIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    tenant: Union[bool, 'TenantArgsFromCandidate']
    conversations: Union[bool, 'FindManyConversationArgsFromCandidate']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromCandidate']


class AgentArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'AgentIncludeFromAgent'


class FindManyAgentArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['AgentOrderByInput', List['AgentOrderByInput']]
    where: 'AgentWhereInput'
    cursor: 'AgentWhereUniqueInput'
    distinct: List['AgentScalarFieldKeys']
    include: 'AgentIncludeFromAgent'


class ConversationIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    agent: Union[bool, 'AgentArgsFromCandidate']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromCandidate']


class ConversationArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'ConversationIncludeFromConversation'


class FindManyConversationArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversation'


class AgentTaskIncludeFromCandidate(TypedDict, total=False):
    """Relational arguments for Candidate"""
    agent: Union[bool, 'AgentArgsFromCandidate']
    conversation: Union[bool, 'ConversationArgsFromCandidate']


class AgentTaskArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    include: 'AgentTaskIncludeFromAgentTask'


class FindManyAgentTaskArgsFromCandidate(TypedDict, total=False):
    """Arguments for Candidate"""
    take: int
    skip: int
    order_by: Union['AgentTaskOrderByInput', List['AgentTaskOrderByInput']]
    where: 'AgentTaskWhereInput'
    cursor: 'AgentTaskWhereUniqueInput'
    distinct: List['AgentTaskScalarFieldKeys']
    include: 'AgentTaskIncludeFromAgentTask'




FindManyCandidateArgs = FindManyCandidateArgsFromCandidate
FindFirstCandidateArgs = FindManyCandidateArgsFromCandidate


class CandidateWhereInput(TypedDict, total=False):
    """Candidate arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    firstName: Union[_str, 'types.StringFilter']
    lastName: Union[_str, 'types.StringFilter']
    email: Union[_str, 'types.StringFilter']
    phone: Union[None, _str, 'types.StringFilter']
    resumeUrl: Union[None, _str, 'types.StringFilter']
    linkedinUrl: Union[None, _str, 'types.StringFilter']
    currentTitle: Union[None, _str, 'types.StringFilter']
    currentCompany: Union[None, _str, 'types.StringFilter']
    careerLevel: 'enums.CareerLevel'
    yearsOfExperience: Union[None, _int, 'types.IntFilter']
    educationLevel: 'enums.EducationLevel'
    skills: 'types.StringListFilter'
    languages: 'types.StringListFilter'
    location: Union[None, _str, 'types.StringFilter']
    currentSalary: Union[None, _float, 'types.FloatFilter']
    expectedSalary: Union[None, _float, 'types.FloatFilter']
    currency: Union[None, _str, 'types.StringFilter']
    noticePeriod: Union[None, _int, 'types.IntFilter']
    noticePeriodUnit: Union[None, _str, 'types.StringFilter']
    visaStatus: Union[None, _str, 'types.StringFilter']
    immigrationStatus: Union[None, _str, 'types.StringFilter']
    immigrationCountry: Union[None, _str, 'types.StringFilter']
    status: 'enums.CandidateStatus'
    source: 'enums.CandidateSource'
    notes: Union[None, _str, 'types.StringFilter']
    jobCandidates: 'JobCandidateListRelationFilter'
    tenantId: Union[None, _str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['CandidateWhereInput', List['CandidateWhereInput']]
    # but this causes mypy to hang :/
    AND: List['CandidateWhereInput']
    OR: List['CandidateWhereInput']
    NOT: List['CandidateWhereInput']



# aggregate Candidate types


class CandidateScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Candidate arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    firstName: Union[_str, 'types.StringWithAggregatesFilter']
    lastName: Union[_str, 'types.StringWithAggregatesFilter']
    email: Union[_str, 'types.StringWithAggregatesFilter']
    phone: Union[_str, 'types.StringWithAggregatesFilter']
    resumeUrl: Union[_str, 'types.StringWithAggregatesFilter']
    linkedinUrl: Union[_str, 'types.StringWithAggregatesFilter']
    currentTitle: Union[_str, 'types.StringWithAggregatesFilter']
    currentCompany: Union[_str, 'types.StringWithAggregatesFilter']
    careerLevel: 'enums.CareerLevel'
    yearsOfExperience: Union[_int, 'types.IntWithAggregatesFilter']
    educationLevel: 'enums.EducationLevel'
    skills: Union[_str, 'types.StringWithAggregatesFilter']
    languages: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    currentSalary: Union[_float, 'types.FloatWithAggregatesFilter']
    expectedSalary: Union[_float, 'types.FloatWithAggregatesFilter']
    currency: Union[_str, 'types.StringWithAggregatesFilter']
    noticePeriod: Union[_int, 'types.IntWithAggregatesFilter']
    noticePeriodUnit: Union[_str, 'types.StringWithAggregatesFilter']
    visaStatus: Union[_str, 'types.StringWithAggregatesFilter']
    immigrationStatus: Union[_str, 'types.StringWithAggregatesFilter']
    immigrationCountry: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.CandidateStatus'
    source: 'enums.CandidateSource'
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['CandidateScalarWhereWithAggregatesInput']
    OR: List['CandidateScalarWhereWithAggregatesInput']
    NOT: List['CandidateScalarWhereWithAggregatesInput']



class CandidateGroupByOutput(TypedDict, total=False):
    id: _str
    firstName: _str
    lastName: _str
    email: _str
    phone: _str
    resumeUrl: _str
    linkedinUrl: _str
    currentTitle: _str
    currentCompany: _str
    careerLevel: 'enums.CareerLevel'
    yearsOfExperience: _int
    educationLevel: 'enums.EducationLevel'
    skills: List[_str]
    languages: List[_str]
    location: _str
    currentSalary: _float
    expectedSalary: _float
    currency: _str
    noticePeriod: _int
    noticePeriodUnit: _str
    visaStatus: _str
    immigrationStatus: _str
    immigrationCountry: _str
    status: 'enums.CandidateStatus'
    source: 'enums.CandidateSource'
    notes: _str
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime
    _sum: 'CandidateSumAggregateOutput'
    _avg: 'CandidateAvgAggregateOutput'
    _min: 'CandidateMinAggregateOutput'
    _max: 'CandidateMaxAggregateOutput'
    _count: 'CandidateCountAggregateOutput'


class CandidateAvgAggregateOutput(TypedDict, total=False):
    """Candidate output for aggregating averages"""
    yearsOfExperience: float
    currentSalary: float
    expectedSalary: float
    noticePeriod: float


class CandidateSumAggregateOutput(TypedDict, total=False):
    """Candidate output for aggregating sums"""
    yearsOfExperience: _int
    currentSalary: _float
    expectedSalary: _float
    noticePeriod: _int


class CandidateScalarAggregateOutput(TypedDict, total=False):
    """Candidate output including scalar fields"""
    id: _str
    firstName: _str
    lastName: _str
    email: _str
    phone: _str
    resumeUrl: _str
    linkedinUrl: _str
    currentTitle: _str
    currentCompany: _str
    careerLevel: 'enums.CareerLevel'
    yearsOfExperience: _int
    educationLevel: 'enums.EducationLevel'
    skills: List[_str]
    languages: List[_str]
    location: _str
    currentSalary: _float
    expectedSalary: _float
    currency: _str
    noticePeriod: _int
    noticePeriodUnit: _str
    visaStatus: _str
    immigrationStatus: _str
    immigrationCountry: _str
    status: 'enums.CandidateStatus'
    source: 'enums.CandidateSource'
    notes: _str
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime


CandidateMinAggregateOutput = CandidateScalarAggregateOutput
CandidateMaxAggregateOutput = CandidateScalarAggregateOutput


class CandidateMaxAggregateInput(TypedDict, total=False):
    """Candidate input for aggregating by max"""
    id: bool
    firstName: bool
    lastName: bool
    email: bool
    phone: bool
    resumeUrl: bool
    linkedinUrl: bool
    currentTitle: bool
    currentCompany: bool
    careerLevel: bool
    yearsOfExperience: bool
    educationLevel: bool
    skills: bool
    languages: bool
    location: bool
    currentSalary: bool
    expectedSalary: bool
    currency: bool
    noticePeriod: bool
    noticePeriodUnit: bool
    visaStatus: bool
    immigrationStatus: bool
    immigrationCountry: bool
    status: bool
    source: bool
    notes: bool
    tenantId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class CandidateMinAggregateInput(TypedDict, total=False):
    """Candidate input for aggregating by min"""
    id: bool
    firstName: bool
    lastName: bool
    email: bool
    phone: bool
    resumeUrl: bool
    linkedinUrl: bool
    currentTitle: bool
    currentCompany: bool
    careerLevel: bool
    yearsOfExperience: bool
    educationLevel: bool
    skills: bool
    languages: bool
    location: bool
    currentSalary: bool
    expectedSalary: bool
    currency: bool
    noticePeriod: bool
    noticePeriodUnit: bool
    visaStatus: bool
    immigrationStatus: bool
    immigrationCountry: bool
    status: bool
    source: bool
    notes: bool
    tenantId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class CandidateNumberAggregateInput(TypedDict, total=False):
    """Candidate input for aggregating numbers"""
    yearsOfExperience: bool
    currentSalary: bool
    expectedSalary: bool
    noticePeriod: bool


CandidateAvgAggregateInput = CandidateNumberAggregateInput
CandidateSumAggregateInput = CandidateNumberAggregateInput


CandidateCountAggregateInput = TypedDict(
    'CandidateCountAggregateInput',
    {
        'id': bool,
        'firstName': bool,
        'lastName': bool,
        'email': bool,
        'phone': bool,
        'resumeUrl': bool,
        'linkedinUrl': bool,
        'currentTitle': bool,
        'currentCompany': bool,
        'careerLevel': bool,
        'yearsOfExperience': bool,
        'educationLevel': bool,
        'skills': bool,
        'languages': bool,
        'location': bool,
        'currentSalary': bool,
        'expectedSalary': bool,
        'currency': bool,
        'noticePeriod': bool,
        'noticePeriodUnit': bool,
        'visaStatus': bool,
        'immigrationStatus': bool,
        'immigrationCountry': bool,
        'status': bool,
        'source': bool,
        'notes': bool,
        'tenantId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deleted': bool,
        'deletedAt': bool,
        '_all': bool,
    },
    total=False,
)

CandidateCountAggregateOutput = TypedDict(
    'CandidateCountAggregateOutput',
    {
        'id': int,
        'firstName': int,
        'lastName': int,
        'email': int,
        'phone': int,
        'resumeUrl': int,
        'linkedinUrl': int,
        'currentTitle': int,
        'currentCompany': int,
        'careerLevel': int,
        'yearsOfExperience': int,
        'educationLevel': int,
        'skills': int,
        'languages': int,
        'location': int,
        'currentSalary': int,
        'expectedSalary': int,
        'currency': int,
        'noticePeriod': int,
        'noticePeriodUnit': int,
        'visaStatus': int,
        'immigrationStatus': int,
        'immigrationCountry': int,
        'status': int,
        'source': int,
        'notes': int,
        'tenantId': int,
        'createdAt': int,
        'updatedAt': int,
        'deleted': int,
        'deletedAt': int,
        '_all': int,
    },
    total=False,
)


CandidateKeys = Literal[
    'id',
    'firstName',
    'lastName',
    'email',
    'phone',
    'resumeUrl',
    'linkedinUrl',
    'currentTitle',
    'currentCompany',
    'careerLevel',
    'yearsOfExperience',
    'educationLevel',
    'skills',
    'languages',
    'location',
    'currentSalary',
    'expectedSalary',
    'currency',
    'noticePeriod',
    'noticePeriodUnit',
    'visaStatus',
    'immigrationStatus',
    'immigrationCountry',
    'status',
    'source',
    'notes',
    'jobCandidates',
    'tenantId',
    'tenant',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
CandidateScalarFieldKeys = Literal[
    'id',
    'firstName',
    'lastName',
    'email',
    'phone',
    'resumeUrl',
    'linkedinUrl',
    'currentTitle',
    'currentCompany',
    'careerLevel',
    'yearsOfExperience',
    'educationLevel',
    'skills',
    'languages',
    'location',
    'currentSalary',
    'expectedSalary',
    'currency',
    'noticePeriod',
    'noticePeriodUnit',
    'visaStatus',
    'immigrationStatus',
    'immigrationCountry',
    'status',
    'source',
    'notes',
    'tenantId',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
CandidateScalarFieldKeysT = TypeVar('CandidateScalarFieldKeysT', bound=CandidateScalarFieldKeys)

CandidateRelationalFieldKeys = Literal[
        'jobCandidates',
        'tenant',
    ]

# Job types

class JobOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Job create method"""
    id: _str
    status: 'enums.JobStatus'
    description: Optional[_str]
    requirements: List[_str]
    keywords: List[_str]
    location: Optional[_str]
    type: Optional[_str]
    salaryRange: Optional[_str]
    department: Optional[_str]
    tenantId: _str
    tenant: 'TenantCreateNestedWithoutRelationsInput'
    jobCandidates: 'JobCandidateCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class JobCreateInput(JobOptionalCreateInput):
    """Required arguments to the Job create method"""
    title: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class JobOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Job create method, without relations"""
    id: _str
    status: 'enums.JobStatus'
    description: Optional[_str]
    requirements: List[_str]
    keywords: List[_str]
    location: Optional[_str]
    type: Optional[_str]
    salaryRange: Optional[_str]
    department: Optional[_str]
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class JobCreateWithoutRelationsInput(JobOptionalCreateWithoutRelationsInput):
    """Required arguments to the Job create method, without relations"""
    title: _str

class JobConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'JobCreateWithoutRelationsInput'
    where: 'JobWhereUniqueInput'

class JobCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'JobCreateWithoutRelationsInput'
    connect: 'JobWhereUniqueInput'
    connect_or_create: 'JobConnectOrCreateWithoutRelationsInput'


class JobCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['JobCreateWithoutRelationsInput', List['JobCreateWithoutRelationsInput']]
    connect: Union['JobWhereUniqueInput', List['JobWhereUniqueInput']]
    connect_or_create: Union['JobConnectOrCreateWithoutRelationsInput', List['JobConnectOrCreateWithoutRelationsInput']]

_JobWhereUnique_id_Input = TypedDict(
    '_JobWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

JobWhereUniqueInput = _JobWhereUnique_id_Input


class JobUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    title: _str
    status: 'enums.JobStatus'
    description: Optional[_str]
    requirements: 'types.StringListUpdate'
    keywords: 'types.StringListUpdate'
    location: Optional[_str]
    type: Optional[_str]
    salaryRange: Optional[_str]
    department: Optional[_str]
    tenant: 'TenantUpdateOneWithoutRelationsInput'
    jobCandidates: 'JobCandidateUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class JobUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    title: _str
    status: 'enums.JobStatus'
    description: Optional[_str]
    requirements: 'types.StringListUpdate'
    keywords: 'types.StringListUpdate'
    location: Optional[_str]
    type: Optional[_str]
    salaryRange: Optional[_str]
    department: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class JobUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['JobCreateWithoutRelationsInput']
    connect: List['JobWhereUniqueInput']
    connect_or_create: List['JobConnectOrCreateWithoutRelationsInput']
    set: List['JobWhereUniqueInput']
    disconnect: List['JobWhereUniqueInput']
    delete: List['JobWhereUniqueInput']

    # TODO
    # update: List['JobUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['JobUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['JobScalarWhereInput']
    # upsert: List['JobUpserteWithWhereUniqueWithoutRelationsInput']


class JobUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'JobCreateWithoutRelationsInput'
    connect: 'JobWhereUniqueInput'
    connect_or_create: 'JobConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'JobUpdateInput'
    # upsert: 'JobUpsertWithoutRelationsInput'


class JobUpsertInput(TypedDict):
    create: 'JobCreateInput'
    update: 'JobUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Job_id_OrderByInput = TypedDict(
    '_Job_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Job_title_OrderByInput = TypedDict(
    '_Job_title_OrderByInput',
    {
        'title': 'SortOrder',
    },
    total=True
)

_Job_status_OrderByInput = TypedDict(
    '_Job_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_Job_description_OrderByInput = TypedDict(
    '_Job_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Job_requirements_OrderByInput = TypedDict(
    '_Job_requirements_OrderByInput',
    {
        'requirements': 'SortOrder',
    },
    total=True
)

_Job_keywords_OrderByInput = TypedDict(
    '_Job_keywords_OrderByInput',
    {
        'keywords': 'SortOrder',
    },
    total=True
)

_Job_location_OrderByInput = TypedDict(
    '_Job_location_OrderByInput',
    {
        'location': 'SortOrder',
    },
    total=True
)

_Job_type_OrderByInput = TypedDict(
    '_Job_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Job_salaryRange_OrderByInput = TypedDict(
    '_Job_salaryRange_OrderByInput',
    {
        'salaryRange': 'SortOrder',
    },
    total=True
)

_Job_department_OrderByInput = TypedDict(
    '_Job_department_OrderByInput',
    {
        'department': 'SortOrder',
    },
    total=True
)

_Job_tenantId_OrderByInput = TypedDict(
    '_Job_tenantId_OrderByInput',
    {
        'tenantId': 'SortOrder',
    },
    total=True
)

_Job_createdAt_OrderByInput = TypedDict(
    '_Job_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Job_updatedAt_OrderByInput = TypedDict(
    '_Job_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Job_deleted_OrderByInput = TypedDict(
    '_Job_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_Job_deletedAt_OrderByInput = TypedDict(
    '_Job_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_Job_RelevanceInner = TypedDict(
    '_Job_RelevanceInner',
    {
        'fields': 'List[JobScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Job_RelevanceOrderByInput = TypedDict(
    '_Job_RelevanceOrderByInput',
    {
        '_relevance': '_Job_RelevanceInner',
    },
    total=True
)

JobOrderByInput = Union[
    '_Job_id_OrderByInput',
    '_Job_title_OrderByInput',
    '_Job_status_OrderByInput',
    '_Job_description_OrderByInput',
    '_Job_requirements_OrderByInput',
    '_Job_keywords_OrderByInput',
    '_Job_location_OrderByInput',
    '_Job_type_OrderByInput',
    '_Job_salaryRange_OrderByInput',
    '_Job_department_OrderByInput',
    '_Job_tenantId_OrderByInput',
    '_Job_createdAt_OrderByInput',
    '_Job_updatedAt_OrderByInput',
    '_Job_deleted_OrderByInput',
    '_Job_deletedAt_OrderByInput',
    '_Job_RelevanceOrderByInput',
]



# recursive Job types
# TODO: cleanup these types



JobRelationFilter = TypedDict(
    'JobRelationFilter',
    {
        'is': 'JobWhereInput',
        'is_not': 'JobWhereInput',
    },
    total=False,
)


class JobListRelationFilter(TypedDict, total=False):
    some: 'JobWhereInput'
    none: 'JobWhereInput'
    every: 'JobWhereInput'


class JobInclude(TypedDict, total=False):
    """Job relational arguments"""
    tenant: Union[bool, 'TenantArgsFromJob']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromJob']


class LicenseIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    tenants: Union[bool, 'FindManyTenantArgsFromJob']


class LicenseArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'LicenseIncludeFromLicense'


class FindManyLicenseArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['LicenseOrderByInput', List['LicenseOrderByInput']]
    where: 'LicenseWhereInput'
    cursor: 'LicenseWhereUniqueInput'
    distinct: List['LicenseScalarFieldKeys']
    include: 'LicenseIncludeFromLicense'


class TenantIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    users: Union[bool, 'FindManyUserArgsFromJob']
    projects: Union[bool, 'FindManyProjectArgsFromJob']
    jobs: Union[bool, 'FindManyJobArgsFromJob']
    agents: Union[bool, 'FindManyAgentArgsFromJob']
    candidates: Union[bool, 'FindManyCandidateArgsFromJob']
    license: Union[bool, 'LicenseArgsFromJob']


class TenantArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class UserRoleIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    users: Union[bool, 'FindManyUserArgsFromJob']


class UserRoleArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'UserRoleIncludeFromUserRole'


class FindManyUserRoleArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['UserRoleOrderByInput', List['UserRoleOrderByInput']]
    where: 'UserRoleWhereInput'
    cursor: 'UserRoleWhereUniqueInput'
    distinct: List['UserRoleScalarFieldKeys']
    include: 'UserRoleIncludeFromUserRole'


class UserIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    role: Union[bool, 'UserRoleArgsFromJob']
    tenant: Union[bool, 'TenantArgsFromJob']
    projects: Union[bool, 'FindManyProjectArgsFromJob']
    sessions: Union[bool, 'FindManyUserSessionArgsFromJob']


class UserArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserSessionIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    user: Union[bool, 'UserArgsFromJob']


class UserSessionArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'UserSessionIncludeFromUserSession'


class FindManyUserSessionArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['UserSessionOrderByInput', List['UserSessionOrderByInput']]
    where: 'UserSessionWhereInput'
    cursor: 'UserSessionWhereUniqueInput'
    distinct: List['UserSessionScalarFieldKeys']
    include: 'UserSessionIncludeFromUserSession'


class CandidateIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromJob']
    tenant: Union[bool, 'TenantArgsFromJob']


class CandidateArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'CandidateIncludeFromCandidate'


class FindManyCandidateArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidate'


class JobIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJob']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromJob']


class JobArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'JobIncludeFromJob'


class FindManyJobArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJob'


class JobCandidateIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    job: Union[bool, 'JobArgsFromJob']
    candidate: Union[bool, 'CandidateArgsFromJob']


class JobCandidateArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'JobCandidateIncludeFromJobCandidate'


class FindManyJobCandidateArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['JobCandidateOrderByInput', List['JobCandidateOrderByInput']]
    where: 'JobCandidateWhereInput'
    cursor: 'JobCandidateWhereUniqueInput'
    distinct: List['JobCandidateScalarFieldKeys']
    include: 'JobCandidateIncludeFromJobCandidate'


class ProjectIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJob']
    user: Union[bool, 'UserArgsFromJob']


class ProjectArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'ProjectIncludeFromProject'


class FindManyProjectArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProject'


class AgentIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    tenant: Union[bool, 'TenantArgsFromJob']
    conversations: Union[bool, 'FindManyConversationArgsFromJob']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromJob']


class AgentArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'AgentIncludeFromAgent'


class FindManyAgentArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['AgentOrderByInput', List['AgentOrderByInput']]
    where: 'AgentWhereInput'
    cursor: 'AgentWhereUniqueInput'
    distinct: List['AgentScalarFieldKeys']
    include: 'AgentIncludeFromAgent'


class ConversationIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    agent: Union[bool, 'AgentArgsFromJob']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromJob']


class ConversationArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'ConversationIncludeFromConversation'


class FindManyConversationArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversation'


class AgentTaskIncludeFromJob(TypedDict, total=False):
    """Relational arguments for Job"""
    agent: Union[bool, 'AgentArgsFromJob']
    conversation: Union[bool, 'ConversationArgsFromJob']


class AgentTaskArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    include: 'AgentTaskIncludeFromAgentTask'


class FindManyAgentTaskArgsFromJob(TypedDict, total=False):
    """Arguments for Job"""
    take: int
    skip: int
    order_by: Union['AgentTaskOrderByInput', List['AgentTaskOrderByInput']]
    where: 'AgentTaskWhereInput'
    cursor: 'AgentTaskWhereUniqueInput'
    distinct: List['AgentTaskScalarFieldKeys']
    include: 'AgentTaskIncludeFromAgentTask'




FindManyJobArgs = FindManyJobArgsFromJob
FindFirstJobArgs = FindManyJobArgsFromJob


class JobWhereInput(TypedDict, total=False):
    """Job arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    title: Union[_str, 'types.StringFilter']
    status: 'enums.JobStatus'
    description: Union[None, _str, 'types.StringFilter']
    requirements: 'types.StringListFilter'
    keywords: 'types.StringListFilter'
    location: Union[None, _str, 'types.StringFilter']
    type: Union[None, _str, 'types.StringFilter']
    salaryRange: Union[None, _str, 'types.StringFilter']
    department: Union[None, _str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    jobCandidates: 'JobCandidateListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['JobWhereInput', List['JobWhereInput']]
    # but this causes mypy to hang :/
    AND: List['JobWhereInput']
    OR: List['JobWhereInput']
    NOT: List['JobWhereInput']



# aggregate Job types


class JobScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Job arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    title: Union[_str, 'types.StringWithAggregatesFilter']
    status: 'enums.JobStatus'
    description: Union[_str, 'types.StringWithAggregatesFilter']
    requirements: Union[_str, 'types.StringWithAggregatesFilter']
    keywords: Union[_str, 'types.StringWithAggregatesFilter']
    location: Union[_str, 'types.StringWithAggregatesFilter']
    type: Union[_str, 'types.StringWithAggregatesFilter']
    salaryRange: Union[_str, 'types.StringWithAggregatesFilter']
    department: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['JobScalarWhereWithAggregatesInput']
    OR: List['JobScalarWhereWithAggregatesInput']
    NOT: List['JobScalarWhereWithAggregatesInput']



class JobGroupByOutput(TypedDict, total=False):
    id: _str
    title: _str
    status: 'enums.JobStatus'
    description: _str
    requirements: List[_str]
    keywords: List[_str]
    location: _str
    type: _str
    salaryRange: _str
    department: _str
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime
    _sum: 'JobSumAggregateOutput'
    _avg: 'JobAvgAggregateOutput'
    _min: 'JobMinAggregateOutput'
    _max: 'JobMaxAggregateOutput'
    _count: 'JobCountAggregateOutput'


class JobAvgAggregateOutput(TypedDict, total=False):
    """Job output for aggregating averages"""


class JobSumAggregateOutput(TypedDict, total=False):
    """Job output for aggregating sums"""


class JobScalarAggregateOutput(TypedDict, total=False):
    """Job output including scalar fields"""
    id: _str
    title: _str
    status: 'enums.JobStatus'
    description: _str
    requirements: List[_str]
    keywords: List[_str]
    location: _str
    type: _str
    salaryRange: _str
    department: _str
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime


JobMinAggregateOutput = JobScalarAggregateOutput
JobMaxAggregateOutput = JobScalarAggregateOutput


class JobMaxAggregateInput(TypedDict, total=False):
    """Job input for aggregating by max"""
    id: bool
    title: bool
    status: bool
    description: bool
    requirements: bool
    keywords: bool
    location: bool
    type: bool
    salaryRange: bool
    department: bool
    tenantId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class JobMinAggregateInput(TypedDict, total=False):
    """Job input for aggregating by min"""
    id: bool
    title: bool
    status: bool
    description: bool
    requirements: bool
    keywords: bool
    location: bool
    type: bool
    salaryRange: bool
    department: bool
    tenantId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class JobNumberAggregateInput(TypedDict, total=False):
    """Job input for aggregating numbers"""


JobAvgAggregateInput = JobNumberAggregateInput
JobSumAggregateInput = JobNumberAggregateInput


JobCountAggregateInput = TypedDict(
    'JobCountAggregateInput',
    {
        'id': bool,
        'title': bool,
        'status': bool,
        'description': bool,
        'requirements': bool,
        'keywords': bool,
        'location': bool,
        'type': bool,
        'salaryRange': bool,
        'department': bool,
        'tenantId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deleted': bool,
        'deletedAt': bool,
        '_all': bool,
    },
    total=False,
)

JobCountAggregateOutput = TypedDict(
    'JobCountAggregateOutput',
    {
        'id': int,
        'title': int,
        'status': int,
        'description': int,
        'requirements': int,
        'keywords': int,
        'location': int,
        'type': int,
        'salaryRange': int,
        'department': int,
        'tenantId': int,
        'createdAt': int,
        'updatedAt': int,
        'deleted': int,
        'deletedAt': int,
        '_all': int,
    },
    total=False,
)


JobKeys = Literal[
    'id',
    'title',
    'status',
    'description',
    'requirements',
    'keywords',
    'location',
    'type',
    'salaryRange',
    'department',
    'tenantId',
    'tenant',
    'jobCandidates',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
JobScalarFieldKeys = Literal[
    'id',
    'title',
    'status',
    'description',
    'requirements',
    'keywords',
    'location',
    'type',
    'salaryRange',
    'department',
    'tenantId',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
JobScalarFieldKeysT = TypeVar('JobScalarFieldKeysT', bound=JobScalarFieldKeys)

JobRelationalFieldKeys = Literal[
        'tenant',
        'jobCandidates',
    ]

# JobCandidate types

class JobCandidateOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the JobCandidate create method"""
    id: _str
    status: _str
    stage: Optional[_str]
    notes: Optional[_str]
    jobId: _str
    job: 'JobCreateNestedWithoutRelationsInput'
    candidateId: _str
    candidate: 'CandidateCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class JobCandidateCreateInput(JobCandidateOptionalCreateInput):
    """Required arguments to the JobCandidate create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class JobCandidateOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the JobCandidate create method, without relations"""
    id: _str
    status: _str
    stage: Optional[_str]
    notes: Optional[_str]
    jobId: _str
    candidateId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class JobCandidateCreateWithoutRelationsInput(JobCandidateOptionalCreateWithoutRelationsInput):
    """Required arguments to the JobCandidate create method, without relations"""

class JobCandidateConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'JobCandidateCreateWithoutRelationsInput'
    where: 'JobCandidateWhereUniqueInput'

class JobCandidateCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'JobCandidateCreateWithoutRelationsInput'
    connect: 'JobCandidateWhereUniqueInput'
    connect_or_create: 'JobCandidateConnectOrCreateWithoutRelationsInput'


class JobCandidateCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['JobCandidateCreateWithoutRelationsInput', List['JobCandidateCreateWithoutRelationsInput']]
    connect: Union['JobCandidateWhereUniqueInput', List['JobCandidateWhereUniqueInput']]
    connect_or_create: Union['JobCandidateConnectOrCreateWithoutRelationsInput', List['JobCandidateConnectOrCreateWithoutRelationsInput']]

_JobCandidateWhereUnique_id_Input = TypedDict(
    '_JobCandidateWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

_JobCandidateCompoundjobId_candidateIdKeyInner = TypedDict(
    '_JobCandidateCompoundjobId_candidateIdKeyInner',
    {
        'jobId': '_str',
        'candidateId': '_str',
    },
    total=True
)

_JobCandidateCompoundjobId_candidateIdKey = TypedDict(
    '_JobCandidateCompoundjobId_candidateIdKey',
    {
        'jobId_candidateId': '_JobCandidateCompoundjobId_candidateIdKeyInner',
    },
    total=True
)

JobCandidateWhereUniqueInput = Union[
    '_JobCandidateWhereUnique_id_Input',
    '_JobCandidateCompoundjobId_candidateIdKey',
]


class JobCandidateUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    status: _str
    stage: Optional[_str]
    notes: Optional[_str]
    job: 'JobUpdateOneWithoutRelationsInput'
    candidate: 'CandidateUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class JobCandidateUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    status: _str
    stage: Optional[_str]
    notes: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class JobCandidateUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['JobCandidateCreateWithoutRelationsInput']
    connect: List['JobCandidateWhereUniqueInput']
    connect_or_create: List['JobCandidateConnectOrCreateWithoutRelationsInput']
    set: List['JobCandidateWhereUniqueInput']
    disconnect: List['JobCandidateWhereUniqueInput']
    delete: List['JobCandidateWhereUniqueInput']

    # TODO
    # update: List['JobCandidateUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['JobCandidateUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['JobCandidateScalarWhereInput']
    # upsert: List['JobCandidateUpserteWithWhereUniqueWithoutRelationsInput']


class JobCandidateUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'JobCandidateCreateWithoutRelationsInput'
    connect: 'JobCandidateWhereUniqueInput'
    connect_or_create: 'JobCandidateConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'JobCandidateUpdateInput'
    # upsert: 'JobCandidateUpsertWithoutRelationsInput'


class JobCandidateUpsertInput(TypedDict):
    create: 'JobCandidateCreateInput'
    update: 'JobCandidateUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_JobCandidate_id_OrderByInput = TypedDict(
    '_JobCandidate_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_JobCandidate_status_OrderByInput = TypedDict(
    '_JobCandidate_status_OrderByInput',
    {
        'status': 'SortOrder',
    },
    total=True
)

_JobCandidate_stage_OrderByInput = TypedDict(
    '_JobCandidate_stage_OrderByInput',
    {
        'stage': 'SortOrder',
    },
    total=True
)

_JobCandidate_notes_OrderByInput = TypedDict(
    '_JobCandidate_notes_OrderByInput',
    {
        'notes': 'SortOrder',
    },
    total=True
)

_JobCandidate_jobId_OrderByInput = TypedDict(
    '_JobCandidate_jobId_OrderByInput',
    {
        'jobId': 'SortOrder',
    },
    total=True
)

_JobCandidate_candidateId_OrderByInput = TypedDict(
    '_JobCandidate_candidateId_OrderByInput',
    {
        'candidateId': 'SortOrder',
    },
    total=True
)

_JobCandidate_createdAt_OrderByInput = TypedDict(
    '_JobCandidate_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_JobCandidate_updatedAt_OrderByInput = TypedDict(
    '_JobCandidate_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_JobCandidate_deleted_OrderByInput = TypedDict(
    '_JobCandidate_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_JobCandidate_deletedAt_OrderByInput = TypedDict(
    '_JobCandidate_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_JobCandidate_RelevanceInner = TypedDict(
    '_JobCandidate_RelevanceInner',
    {
        'fields': 'List[JobCandidateScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_JobCandidate_RelevanceOrderByInput = TypedDict(
    '_JobCandidate_RelevanceOrderByInput',
    {
        '_relevance': '_JobCandidate_RelevanceInner',
    },
    total=True
)

JobCandidateOrderByInput = Union[
    '_JobCandidate_id_OrderByInput',
    '_JobCandidate_status_OrderByInput',
    '_JobCandidate_stage_OrderByInput',
    '_JobCandidate_notes_OrderByInput',
    '_JobCandidate_jobId_OrderByInput',
    '_JobCandidate_candidateId_OrderByInput',
    '_JobCandidate_createdAt_OrderByInput',
    '_JobCandidate_updatedAt_OrderByInput',
    '_JobCandidate_deleted_OrderByInput',
    '_JobCandidate_deletedAt_OrderByInput',
    '_JobCandidate_RelevanceOrderByInput',
]



# recursive JobCandidate types
# TODO: cleanup these types



JobCandidateRelationFilter = TypedDict(
    'JobCandidateRelationFilter',
    {
        'is': 'JobCandidateWhereInput',
        'is_not': 'JobCandidateWhereInput',
    },
    total=False,
)


class JobCandidateListRelationFilter(TypedDict, total=False):
    some: 'JobCandidateWhereInput'
    none: 'JobCandidateWhereInput'
    every: 'JobCandidateWhereInput'


class JobCandidateInclude(TypedDict, total=False):
    """JobCandidate relational arguments"""
    job: Union[bool, 'JobArgsFromJobCandidate']
    candidate: Union[bool, 'CandidateArgsFromJobCandidate']


class LicenseIncludeFromJobCandidate(TypedDict, total=False):
    """Relational arguments for JobCandidate"""
    tenants: Union[bool, 'FindManyTenantArgsFromJobCandidate']


class LicenseArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    include: 'LicenseIncludeFromLicense'


class FindManyLicenseArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    take: int
    skip: int
    order_by: Union['LicenseOrderByInput', List['LicenseOrderByInput']]
    where: 'LicenseWhereInput'
    cursor: 'LicenseWhereUniqueInput'
    distinct: List['LicenseScalarFieldKeys']
    include: 'LicenseIncludeFromLicense'


class TenantIncludeFromJobCandidate(TypedDict, total=False):
    """Relational arguments for JobCandidate"""
    users: Union[bool, 'FindManyUserArgsFromJobCandidate']
    projects: Union[bool, 'FindManyProjectArgsFromJobCandidate']
    jobs: Union[bool, 'FindManyJobArgsFromJobCandidate']
    agents: Union[bool, 'FindManyAgentArgsFromJobCandidate']
    candidates: Union[bool, 'FindManyCandidateArgsFromJobCandidate']
    license: Union[bool, 'LicenseArgsFromJobCandidate']


class TenantArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class UserRoleIncludeFromJobCandidate(TypedDict, total=False):
    """Relational arguments for JobCandidate"""
    users: Union[bool, 'FindManyUserArgsFromJobCandidate']


class UserRoleArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    include: 'UserRoleIncludeFromUserRole'


class FindManyUserRoleArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    take: int
    skip: int
    order_by: Union['UserRoleOrderByInput', List['UserRoleOrderByInput']]
    where: 'UserRoleWhereInput'
    cursor: 'UserRoleWhereUniqueInput'
    distinct: List['UserRoleScalarFieldKeys']
    include: 'UserRoleIncludeFromUserRole'


class UserIncludeFromJobCandidate(TypedDict, total=False):
    """Relational arguments for JobCandidate"""
    role: Union[bool, 'UserRoleArgsFromJobCandidate']
    tenant: Union[bool, 'TenantArgsFromJobCandidate']
    projects: Union[bool, 'FindManyProjectArgsFromJobCandidate']
    sessions: Union[bool, 'FindManyUserSessionArgsFromJobCandidate']


class UserArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserSessionIncludeFromJobCandidate(TypedDict, total=False):
    """Relational arguments for JobCandidate"""
    user: Union[bool, 'UserArgsFromJobCandidate']


class UserSessionArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    include: 'UserSessionIncludeFromUserSession'


class FindManyUserSessionArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    take: int
    skip: int
    order_by: Union['UserSessionOrderByInput', List['UserSessionOrderByInput']]
    where: 'UserSessionWhereInput'
    cursor: 'UserSessionWhereUniqueInput'
    distinct: List['UserSessionScalarFieldKeys']
    include: 'UserSessionIncludeFromUserSession'


class CandidateIncludeFromJobCandidate(TypedDict, total=False):
    """Relational arguments for JobCandidate"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromJobCandidate']
    tenant: Union[bool, 'TenantArgsFromJobCandidate']


class CandidateArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    include: 'CandidateIncludeFromCandidate'


class FindManyCandidateArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidate'


class JobIncludeFromJobCandidate(TypedDict, total=False):
    """Relational arguments for JobCandidate"""
    tenant: Union[bool, 'TenantArgsFromJobCandidate']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromJobCandidate']


class JobArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    include: 'JobIncludeFromJob'


class FindManyJobArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJob'


class JobCandidateIncludeFromJobCandidate(TypedDict, total=False):
    """Relational arguments for JobCandidate"""
    job: Union[bool, 'JobArgsFromJobCandidate']
    candidate: Union[bool, 'CandidateArgsFromJobCandidate']


class JobCandidateArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    include: 'JobCandidateIncludeFromJobCandidate'


class FindManyJobCandidateArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    take: int
    skip: int
    order_by: Union['JobCandidateOrderByInput', List['JobCandidateOrderByInput']]
    where: 'JobCandidateWhereInput'
    cursor: 'JobCandidateWhereUniqueInput'
    distinct: List['JobCandidateScalarFieldKeys']
    include: 'JobCandidateIncludeFromJobCandidate'


class ProjectIncludeFromJobCandidate(TypedDict, total=False):
    """Relational arguments for JobCandidate"""
    tenant: Union[bool, 'TenantArgsFromJobCandidate']
    user: Union[bool, 'UserArgsFromJobCandidate']


class ProjectArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    include: 'ProjectIncludeFromProject'


class FindManyProjectArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProject'


class AgentIncludeFromJobCandidate(TypedDict, total=False):
    """Relational arguments for JobCandidate"""
    tenant: Union[bool, 'TenantArgsFromJobCandidate']
    conversations: Union[bool, 'FindManyConversationArgsFromJobCandidate']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromJobCandidate']


class AgentArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    include: 'AgentIncludeFromAgent'


class FindManyAgentArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    take: int
    skip: int
    order_by: Union['AgentOrderByInput', List['AgentOrderByInput']]
    where: 'AgentWhereInput'
    cursor: 'AgentWhereUniqueInput'
    distinct: List['AgentScalarFieldKeys']
    include: 'AgentIncludeFromAgent'


class ConversationIncludeFromJobCandidate(TypedDict, total=False):
    """Relational arguments for JobCandidate"""
    agent: Union[bool, 'AgentArgsFromJobCandidate']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromJobCandidate']


class ConversationArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    include: 'ConversationIncludeFromConversation'


class FindManyConversationArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversation'


class AgentTaskIncludeFromJobCandidate(TypedDict, total=False):
    """Relational arguments for JobCandidate"""
    agent: Union[bool, 'AgentArgsFromJobCandidate']
    conversation: Union[bool, 'ConversationArgsFromJobCandidate']


class AgentTaskArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    include: 'AgentTaskIncludeFromAgentTask'


class FindManyAgentTaskArgsFromJobCandidate(TypedDict, total=False):
    """Arguments for JobCandidate"""
    take: int
    skip: int
    order_by: Union['AgentTaskOrderByInput', List['AgentTaskOrderByInput']]
    where: 'AgentTaskWhereInput'
    cursor: 'AgentTaskWhereUniqueInput'
    distinct: List['AgentTaskScalarFieldKeys']
    include: 'AgentTaskIncludeFromAgentTask'




FindManyJobCandidateArgs = FindManyJobCandidateArgsFromJobCandidate
FindFirstJobCandidateArgs = FindManyJobCandidateArgsFromJobCandidate


class JobCandidateWhereInput(TypedDict, total=False):
    """JobCandidate arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    status: Union[_str, 'types.StringFilter']
    stage: Union[None, _str, 'types.StringFilter']
    notes: Union[None, _str, 'types.StringFilter']
    jobId: Union[_str, 'types.StringFilter']
    job: 'JobRelationFilter'
    candidateId: Union[_str, 'types.StringFilter']
    candidate: 'CandidateRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['JobCandidateWhereInput', List['JobCandidateWhereInput']]
    # but this causes mypy to hang :/
    AND: List['JobCandidateWhereInput']
    OR: List['JobCandidateWhereInput']
    NOT: List['JobCandidateWhereInput']



# aggregate JobCandidate types


class JobCandidateScalarWhereWithAggregatesInput(TypedDict, total=False):
    """JobCandidate arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    status: Union[_str, 'types.StringWithAggregatesFilter']
    stage: Union[_str, 'types.StringWithAggregatesFilter']
    notes: Union[_str, 'types.StringWithAggregatesFilter']
    jobId: Union[_str, 'types.StringWithAggregatesFilter']
    candidateId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['JobCandidateScalarWhereWithAggregatesInput']
    OR: List['JobCandidateScalarWhereWithAggregatesInput']
    NOT: List['JobCandidateScalarWhereWithAggregatesInput']



class JobCandidateGroupByOutput(TypedDict, total=False):
    id: _str
    status: _str
    stage: _str
    notes: _str
    jobId: _str
    candidateId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime
    _sum: 'JobCandidateSumAggregateOutput'
    _avg: 'JobCandidateAvgAggregateOutput'
    _min: 'JobCandidateMinAggregateOutput'
    _max: 'JobCandidateMaxAggregateOutput'
    _count: 'JobCandidateCountAggregateOutput'


class JobCandidateAvgAggregateOutput(TypedDict, total=False):
    """JobCandidate output for aggregating averages"""


class JobCandidateSumAggregateOutput(TypedDict, total=False):
    """JobCandidate output for aggregating sums"""


class JobCandidateScalarAggregateOutput(TypedDict, total=False):
    """JobCandidate output including scalar fields"""
    id: _str
    status: _str
    stage: _str
    notes: _str
    jobId: _str
    candidateId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime


JobCandidateMinAggregateOutput = JobCandidateScalarAggregateOutput
JobCandidateMaxAggregateOutput = JobCandidateScalarAggregateOutput


class JobCandidateMaxAggregateInput(TypedDict, total=False):
    """JobCandidate input for aggregating by max"""
    id: bool
    status: bool
    stage: bool
    notes: bool
    jobId: bool
    candidateId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class JobCandidateMinAggregateInput(TypedDict, total=False):
    """JobCandidate input for aggregating by min"""
    id: bool
    status: bool
    stage: bool
    notes: bool
    jobId: bool
    candidateId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class JobCandidateNumberAggregateInput(TypedDict, total=False):
    """JobCandidate input for aggregating numbers"""


JobCandidateAvgAggregateInput = JobCandidateNumberAggregateInput
JobCandidateSumAggregateInput = JobCandidateNumberAggregateInput


JobCandidateCountAggregateInput = TypedDict(
    'JobCandidateCountAggregateInput',
    {
        'id': bool,
        'status': bool,
        'stage': bool,
        'notes': bool,
        'jobId': bool,
        'candidateId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deleted': bool,
        'deletedAt': bool,
        '_all': bool,
    },
    total=False,
)

JobCandidateCountAggregateOutput = TypedDict(
    'JobCandidateCountAggregateOutput',
    {
        'id': int,
        'status': int,
        'stage': int,
        'notes': int,
        'jobId': int,
        'candidateId': int,
        'createdAt': int,
        'updatedAt': int,
        'deleted': int,
        'deletedAt': int,
        '_all': int,
    },
    total=False,
)


JobCandidateKeys = Literal[
    'id',
    'status',
    'stage',
    'notes',
    'jobId',
    'job',
    'candidateId',
    'candidate',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
JobCandidateScalarFieldKeys = Literal[
    'id',
    'status',
    'stage',
    'notes',
    'jobId',
    'candidateId',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
JobCandidateScalarFieldKeysT = TypeVar('JobCandidateScalarFieldKeysT', bound=JobCandidateScalarFieldKeys)

JobCandidateRelationalFieldKeys = Literal[
        'job',
        'candidate',
    ]

# Project types

class ProjectOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Project create method"""
    id: _str
    description: Optional[_str]
    query: Optional[_str]
    tenantId: _str
    tenant: 'TenantCreateNestedWithoutRelationsInput'
    userId: _str
    user: 'UserCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class ProjectCreateInput(ProjectOptionalCreateInput):
    """Required arguments to the Project create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ProjectOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Project create method, without relations"""
    id: _str
    description: Optional[_str]
    query: Optional[_str]
    tenantId: _str
    userId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class ProjectCreateWithoutRelationsInput(ProjectOptionalCreateWithoutRelationsInput):
    """Required arguments to the Project create method, without relations"""
    name: _str

class ProjectConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ProjectCreateWithoutRelationsInput'
    where: 'ProjectWhereUniqueInput'

class ProjectCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ProjectCreateWithoutRelationsInput'
    connect: 'ProjectWhereUniqueInput'
    connect_or_create: 'ProjectConnectOrCreateWithoutRelationsInput'


class ProjectCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ProjectCreateWithoutRelationsInput', List['ProjectCreateWithoutRelationsInput']]
    connect: Union['ProjectWhereUniqueInput', List['ProjectWhereUniqueInput']]
    connect_or_create: Union['ProjectConnectOrCreateWithoutRelationsInput', List['ProjectConnectOrCreateWithoutRelationsInput']]

_ProjectWhereUnique_id_Input = TypedDict(
    '_ProjectWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ProjectWhereUniqueInput = _ProjectWhereUnique_id_Input


class ProjectUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    description: Optional[_str]
    query: Optional[_str]
    tenant: 'TenantUpdateOneWithoutRelationsInput'
    user: 'UserUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class ProjectUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    description: Optional[_str]
    query: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class ProjectUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ProjectCreateWithoutRelationsInput']
    connect: List['ProjectWhereUniqueInput']
    connect_or_create: List['ProjectConnectOrCreateWithoutRelationsInput']
    set: List['ProjectWhereUniqueInput']
    disconnect: List['ProjectWhereUniqueInput']
    delete: List['ProjectWhereUniqueInput']

    # TODO
    # update: List['ProjectUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ProjectUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ProjectScalarWhereInput']
    # upsert: List['ProjectUpserteWithWhereUniqueWithoutRelationsInput']


class ProjectUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ProjectCreateWithoutRelationsInput'
    connect: 'ProjectWhereUniqueInput'
    connect_or_create: 'ProjectConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ProjectUpdateInput'
    # upsert: 'ProjectUpsertWithoutRelationsInput'


class ProjectUpsertInput(TypedDict):
    create: 'ProjectCreateInput'
    update: 'ProjectUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Project_id_OrderByInput = TypedDict(
    '_Project_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Project_name_OrderByInput = TypedDict(
    '_Project_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Project_description_OrderByInput = TypedDict(
    '_Project_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Project_query_OrderByInput = TypedDict(
    '_Project_query_OrderByInput',
    {
        'query': 'SortOrder',
    },
    total=True
)

_Project_tenantId_OrderByInput = TypedDict(
    '_Project_tenantId_OrderByInput',
    {
        'tenantId': 'SortOrder',
    },
    total=True
)

_Project_userId_OrderByInput = TypedDict(
    '_Project_userId_OrderByInput',
    {
        'userId': 'SortOrder',
    },
    total=True
)

_Project_createdAt_OrderByInput = TypedDict(
    '_Project_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Project_updatedAt_OrderByInput = TypedDict(
    '_Project_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Project_deleted_OrderByInput = TypedDict(
    '_Project_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_Project_deletedAt_OrderByInput = TypedDict(
    '_Project_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_Project_RelevanceInner = TypedDict(
    '_Project_RelevanceInner',
    {
        'fields': 'List[ProjectScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Project_RelevanceOrderByInput = TypedDict(
    '_Project_RelevanceOrderByInput',
    {
        '_relevance': '_Project_RelevanceInner',
    },
    total=True
)

ProjectOrderByInput = Union[
    '_Project_id_OrderByInput',
    '_Project_name_OrderByInput',
    '_Project_description_OrderByInput',
    '_Project_query_OrderByInput',
    '_Project_tenantId_OrderByInput',
    '_Project_userId_OrderByInput',
    '_Project_createdAt_OrderByInput',
    '_Project_updatedAt_OrderByInput',
    '_Project_deleted_OrderByInput',
    '_Project_deletedAt_OrderByInput',
    '_Project_RelevanceOrderByInput',
]



# recursive Project types
# TODO: cleanup these types



ProjectRelationFilter = TypedDict(
    'ProjectRelationFilter',
    {
        'is': 'ProjectWhereInput',
        'is_not': 'ProjectWhereInput',
    },
    total=False,
)


class ProjectListRelationFilter(TypedDict, total=False):
    some: 'ProjectWhereInput'
    none: 'ProjectWhereInput'
    every: 'ProjectWhereInput'


class ProjectInclude(TypedDict, total=False):
    """Project relational arguments"""
    tenant: Union[bool, 'TenantArgsFromProject']
    user: Union[bool, 'UserArgsFromProject']


class LicenseIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    tenants: Union[bool, 'FindManyTenantArgsFromProject']


class LicenseArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'LicenseIncludeFromLicense'


class FindManyLicenseArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['LicenseOrderByInput', List['LicenseOrderByInput']]
    where: 'LicenseWhereInput'
    cursor: 'LicenseWhereUniqueInput'
    distinct: List['LicenseScalarFieldKeys']
    include: 'LicenseIncludeFromLicense'


class TenantIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    users: Union[bool, 'FindManyUserArgsFromProject']
    projects: Union[bool, 'FindManyProjectArgsFromProject']
    jobs: Union[bool, 'FindManyJobArgsFromProject']
    agents: Union[bool, 'FindManyAgentArgsFromProject']
    candidates: Union[bool, 'FindManyCandidateArgsFromProject']
    license: Union[bool, 'LicenseArgsFromProject']


class TenantArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class UserRoleIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    users: Union[bool, 'FindManyUserArgsFromProject']


class UserRoleArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'UserRoleIncludeFromUserRole'


class FindManyUserRoleArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['UserRoleOrderByInput', List['UserRoleOrderByInput']]
    where: 'UserRoleWhereInput'
    cursor: 'UserRoleWhereUniqueInput'
    distinct: List['UserRoleScalarFieldKeys']
    include: 'UserRoleIncludeFromUserRole'


class UserIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    role: Union[bool, 'UserRoleArgsFromProject']
    tenant: Union[bool, 'TenantArgsFromProject']
    projects: Union[bool, 'FindManyProjectArgsFromProject']
    sessions: Union[bool, 'FindManyUserSessionArgsFromProject']


class UserArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserSessionIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    user: Union[bool, 'UserArgsFromProject']


class UserSessionArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'UserSessionIncludeFromUserSession'


class FindManyUserSessionArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['UserSessionOrderByInput', List['UserSessionOrderByInput']]
    where: 'UserSessionWhereInput'
    cursor: 'UserSessionWhereUniqueInput'
    distinct: List['UserSessionScalarFieldKeys']
    include: 'UserSessionIncludeFromUserSession'


class CandidateIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromProject']
    tenant: Union[bool, 'TenantArgsFromProject']


class CandidateArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'CandidateIncludeFromCandidate'


class FindManyCandidateArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidate'


class JobIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    tenant: Union[bool, 'TenantArgsFromProject']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromProject']


class JobArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'JobIncludeFromJob'


class FindManyJobArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJob'


class JobCandidateIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    job: Union[bool, 'JobArgsFromProject']
    candidate: Union[bool, 'CandidateArgsFromProject']


class JobCandidateArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'JobCandidateIncludeFromJobCandidate'


class FindManyJobCandidateArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['JobCandidateOrderByInput', List['JobCandidateOrderByInput']]
    where: 'JobCandidateWhereInput'
    cursor: 'JobCandidateWhereUniqueInput'
    distinct: List['JobCandidateScalarFieldKeys']
    include: 'JobCandidateIncludeFromJobCandidate'


class ProjectIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    tenant: Union[bool, 'TenantArgsFromProject']
    user: Union[bool, 'UserArgsFromProject']


class ProjectArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ProjectIncludeFromProject'


class FindManyProjectArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProject'


class AgentIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    tenant: Union[bool, 'TenantArgsFromProject']
    conversations: Union[bool, 'FindManyConversationArgsFromProject']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromProject']


class AgentArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'AgentIncludeFromAgent'


class FindManyAgentArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['AgentOrderByInput', List['AgentOrderByInput']]
    where: 'AgentWhereInput'
    cursor: 'AgentWhereUniqueInput'
    distinct: List['AgentScalarFieldKeys']
    include: 'AgentIncludeFromAgent'


class ConversationIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    agent: Union[bool, 'AgentArgsFromProject']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromProject']


class ConversationArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'ConversationIncludeFromConversation'


class FindManyConversationArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversation'


class AgentTaskIncludeFromProject(TypedDict, total=False):
    """Relational arguments for Project"""
    agent: Union[bool, 'AgentArgsFromProject']
    conversation: Union[bool, 'ConversationArgsFromProject']


class AgentTaskArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    include: 'AgentTaskIncludeFromAgentTask'


class FindManyAgentTaskArgsFromProject(TypedDict, total=False):
    """Arguments for Project"""
    take: int
    skip: int
    order_by: Union['AgentTaskOrderByInput', List['AgentTaskOrderByInput']]
    where: 'AgentTaskWhereInput'
    cursor: 'AgentTaskWhereUniqueInput'
    distinct: List['AgentTaskScalarFieldKeys']
    include: 'AgentTaskIncludeFromAgentTask'




FindManyProjectArgs = FindManyProjectArgsFromProject
FindFirstProjectArgs = FindManyProjectArgsFromProject


class ProjectWhereInput(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    query: Union[None, _str, 'types.StringFilter']
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    userId: Union[_str, 'types.StringFilter']
    user: 'UserRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ProjectWhereInput', List['ProjectWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ProjectWhereInput']
    OR: List['ProjectWhereInput']
    NOT: List['ProjectWhereInput']



# aggregate Project types


class ProjectScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Project arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    query: Union[_str, 'types.StringWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    userId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ProjectScalarWhereWithAggregatesInput']
    OR: List['ProjectScalarWhereWithAggregatesInput']
    NOT: List['ProjectScalarWhereWithAggregatesInput']



class ProjectGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    description: _str
    query: _str
    tenantId: _str
    userId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime
    _sum: 'ProjectSumAggregateOutput'
    _avg: 'ProjectAvgAggregateOutput'
    _min: 'ProjectMinAggregateOutput'
    _max: 'ProjectMaxAggregateOutput'
    _count: 'ProjectCountAggregateOutput'


class ProjectAvgAggregateOutput(TypedDict, total=False):
    """Project output for aggregating averages"""


class ProjectSumAggregateOutput(TypedDict, total=False):
    """Project output for aggregating sums"""


class ProjectScalarAggregateOutput(TypedDict, total=False):
    """Project output including scalar fields"""
    id: _str
    name: _str
    description: _str
    query: _str
    tenantId: _str
    userId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime


ProjectMinAggregateOutput = ProjectScalarAggregateOutput
ProjectMaxAggregateOutput = ProjectScalarAggregateOutput


class ProjectMaxAggregateInput(TypedDict, total=False):
    """Project input for aggregating by max"""
    id: bool
    name: bool
    description: bool
    query: bool
    tenantId: bool
    userId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class ProjectMinAggregateInput(TypedDict, total=False):
    """Project input for aggregating by min"""
    id: bool
    name: bool
    description: bool
    query: bool
    tenantId: bool
    userId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class ProjectNumberAggregateInput(TypedDict, total=False):
    """Project input for aggregating numbers"""


ProjectAvgAggregateInput = ProjectNumberAggregateInput
ProjectSumAggregateInput = ProjectNumberAggregateInput


ProjectCountAggregateInput = TypedDict(
    'ProjectCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'description': bool,
        'query': bool,
        'tenantId': bool,
        'userId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deleted': bool,
        'deletedAt': bool,
        '_all': bool,
    },
    total=False,
)

ProjectCountAggregateOutput = TypedDict(
    'ProjectCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'description': int,
        'query': int,
        'tenantId': int,
        'userId': int,
        'createdAt': int,
        'updatedAt': int,
        'deleted': int,
        'deletedAt': int,
        '_all': int,
    },
    total=False,
)


ProjectKeys = Literal[
    'id',
    'name',
    'description',
    'query',
    'tenantId',
    'tenant',
    'userId',
    'user',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
ProjectScalarFieldKeys = Literal[
    'id',
    'name',
    'description',
    'query',
    'tenantId',
    'userId',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
ProjectScalarFieldKeysT = TypeVar('ProjectScalarFieldKeysT', bound=ProjectScalarFieldKeys)

ProjectRelationalFieldKeys = Literal[
        'tenant',
        'user',
    ]

# Agent types

class AgentOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Agent create method"""
    id: _str
    description: Optional[_str]
    type: 'enums.AgentType'
    prompt: Optional[_str]
    temperature: Optional[_float]
    maxTokens: Optional[_int]
    topP: Optional[_float]
    frequencyPenalty: Optional[_float]
    presencePenalty: Optional[_float]
    stopSequence: List[_str]
    stopSequenceTokens: List[_str]
    config: Optional['fields.Json']
    tenantId: _str
    tenant: 'TenantCreateNestedWithoutRelationsInput'
    conversations: 'ConversationCreateManyNestedWithoutRelationsInput'
    agentTasks: 'AgentTaskCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class AgentCreateInput(AgentOptionalCreateInput):
    """Required arguments to the Agent create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AgentOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Agent create method, without relations"""
    id: _str
    description: Optional[_str]
    type: 'enums.AgentType'
    prompt: Optional[_str]
    temperature: Optional[_float]
    maxTokens: Optional[_int]
    topP: Optional[_float]
    frequencyPenalty: Optional[_float]
    presencePenalty: Optional[_float]
    stopSequence: List[_str]
    stopSequenceTokens: List[_str]
    config: Optional['fields.Json']
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class AgentCreateWithoutRelationsInput(AgentOptionalCreateWithoutRelationsInput):
    """Required arguments to the Agent create method, without relations"""
    name: _str

class AgentConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'AgentCreateWithoutRelationsInput'
    where: 'AgentWhereUniqueInput'

class AgentCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AgentCreateWithoutRelationsInput'
    connect: 'AgentWhereUniqueInput'
    connect_or_create: 'AgentConnectOrCreateWithoutRelationsInput'


class AgentCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AgentCreateWithoutRelationsInput', List['AgentCreateWithoutRelationsInput']]
    connect: Union['AgentWhereUniqueInput', List['AgentWhereUniqueInput']]
    connect_or_create: Union['AgentConnectOrCreateWithoutRelationsInput', List['AgentConnectOrCreateWithoutRelationsInput']]

_AgentWhereUnique_id_Input = TypedDict(
    '_AgentWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

AgentWhereUniqueInput = _AgentWhereUnique_id_Input


class AgentUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    name: _str
    description: Optional[_str]
    type: 'enums.AgentType'
    prompt: Optional[_str]
    temperature: Optional[Union[AtomicFloatInput, _float]]
    maxTokens: Optional[Union[AtomicIntInput, _int]]
    topP: Optional[Union[AtomicFloatInput, _float]]
    frequencyPenalty: Optional[Union[AtomicFloatInput, _float]]
    presencePenalty: Optional[Union[AtomicFloatInput, _float]]
    stopSequence: 'types.StringListUpdate'
    stopSequenceTokens: 'types.StringListUpdate'
    config: Optional['fields.Json']
    tenant: 'TenantUpdateOneWithoutRelationsInput'
    conversations: 'ConversationUpdateManyWithoutRelationsInput'
    agentTasks: 'AgentTaskUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class AgentUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    description: Optional[_str]
    type: 'enums.AgentType'
    prompt: Optional[_str]
    temperature: Optional[Union[AtomicFloatInput, _float]]
    maxTokens: Optional[Union[AtomicIntInput, _int]]
    topP: Optional[Union[AtomicFloatInput, _float]]
    frequencyPenalty: Optional[Union[AtomicFloatInput, _float]]
    presencePenalty: Optional[Union[AtomicFloatInput, _float]]
    stopSequence: 'types.StringListUpdate'
    stopSequenceTokens: 'types.StringListUpdate'
    config: Optional['fields.Json']
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class AgentUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AgentCreateWithoutRelationsInput']
    connect: List['AgentWhereUniqueInput']
    connect_or_create: List['AgentConnectOrCreateWithoutRelationsInput']
    set: List['AgentWhereUniqueInput']
    disconnect: List['AgentWhereUniqueInput']
    delete: List['AgentWhereUniqueInput']

    # TODO
    # update: List['AgentUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AgentUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AgentScalarWhereInput']
    # upsert: List['AgentUpserteWithWhereUniqueWithoutRelationsInput']


class AgentUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AgentCreateWithoutRelationsInput'
    connect: 'AgentWhereUniqueInput'
    connect_or_create: 'AgentConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AgentUpdateInput'
    # upsert: 'AgentUpsertWithoutRelationsInput'


class AgentUpsertInput(TypedDict):
    create: 'AgentCreateInput'
    update: 'AgentUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Agent_id_OrderByInput = TypedDict(
    '_Agent_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Agent_name_OrderByInput = TypedDict(
    '_Agent_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Agent_description_OrderByInput = TypedDict(
    '_Agent_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_Agent_type_OrderByInput = TypedDict(
    '_Agent_type_OrderByInput',
    {
        'type': 'SortOrder',
    },
    total=True
)

_Agent_prompt_OrderByInput = TypedDict(
    '_Agent_prompt_OrderByInput',
    {
        'prompt': 'SortOrder',
    },
    total=True
)

_Agent_temperature_OrderByInput = TypedDict(
    '_Agent_temperature_OrderByInput',
    {
        'temperature': 'SortOrder',
    },
    total=True
)

_Agent_maxTokens_OrderByInput = TypedDict(
    '_Agent_maxTokens_OrderByInput',
    {
        'maxTokens': 'SortOrder',
    },
    total=True
)

_Agent_topP_OrderByInput = TypedDict(
    '_Agent_topP_OrderByInput',
    {
        'topP': 'SortOrder',
    },
    total=True
)

_Agent_frequencyPenalty_OrderByInput = TypedDict(
    '_Agent_frequencyPenalty_OrderByInput',
    {
        'frequencyPenalty': 'SortOrder',
    },
    total=True
)

_Agent_presencePenalty_OrderByInput = TypedDict(
    '_Agent_presencePenalty_OrderByInput',
    {
        'presencePenalty': 'SortOrder',
    },
    total=True
)

_Agent_stopSequence_OrderByInput = TypedDict(
    '_Agent_stopSequence_OrderByInput',
    {
        'stopSequence': 'SortOrder',
    },
    total=True
)

_Agent_stopSequenceTokens_OrderByInput = TypedDict(
    '_Agent_stopSequenceTokens_OrderByInput',
    {
        'stopSequenceTokens': 'SortOrder',
    },
    total=True
)

_Agent_config_OrderByInput = TypedDict(
    '_Agent_config_OrderByInput',
    {
        'config': 'SortOrder',
    },
    total=True
)

_Agent_tenantId_OrderByInput = TypedDict(
    '_Agent_tenantId_OrderByInput',
    {
        'tenantId': 'SortOrder',
    },
    total=True
)

_Agent_createdAt_OrderByInput = TypedDict(
    '_Agent_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Agent_updatedAt_OrderByInput = TypedDict(
    '_Agent_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Agent_deleted_OrderByInput = TypedDict(
    '_Agent_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_Agent_deletedAt_OrderByInput = TypedDict(
    '_Agent_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_Agent_RelevanceInner = TypedDict(
    '_Agent_RelevanceInner',
    {
        'fields': 'List[AgentScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Agent_RelevanceOrderByInput = TypedDict(
    '_Agent_RelevanceOrderByInput',
    {
        '_relevance': '_Agent_RelevanceInner',
    },
    total=True
)

AgentOrderByInput = Union[
    '_Agent_id_OrderByInput',
    '_Agent_name_OrderByInput',
    '_Agent_description_OrderByInput',
    '_Agent_type_OrderByInput',
    '_Agent_prompt_OrderByInput',
    '_Agent_temperature_OrderByInput',
    '_Agent_maxTokens_OrderByInput',
    '_Agent_topP_OrderByInput',
    '_Agent_frequencyPenalty_OrderByInput',
    '_Agent_presencePenalty_OrderByInput',
    '_Agent_stopSequence_OrderByInput',
    '_Agent_stopSequenceTokens_OrderByInput',
    '_Agent_config_OrderByInput',
    '_Agent_tenantId_OrderByInput',
    '_Agent_createdAt_OrderByInput',
    '_Agent_updatedAt_OrderByInput',
    '_Agent_deleted_OrderByInput',
    '_Agent_deletedAt_OrderByInput',
    '_Agent_RelevanceOrderByInput',
]



# recursive Agent types
# TODO: cleanup these types



AgentRelationFilter = TypedDict(
    'AgentRelationFilter',
    {
        'is': 'AgentWhereInput',
        'is_not': 'AgentWhereInput',
    },
    total=False,
)


class AgentListRelationFilter(TypedDict, total=False):
    some: 'AgentWhereInput'
    none: 'AgentWhereInput'
    every: 'AgentWhereInput'


class AgentInclude(TypedDict, total=False):
    """Agent relational arguments"""
    tenant: Union[bool, 'TenantArgsFromAgent']
    conversations: Union[bool, 'FindManyConversationArgsFromAgent']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromAgent']


class LicenseIncludeFromAgent(TypedDict, total=False):
    """Relational arguments for Agent"""
    tenants: Union[bool, 'FindManyTenantArgsFromAgent']


class LicenseArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    include: 'LicenseIncludeFromLicense'


class FindManyLicenseArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    take: int
    skip: int
    order_by: Union['LicenseOrderByInput', List['LicenseOrderByInput']]
    where: 'LicenseWhereInput'
    cursor: 'LicenseWhereUniqueInput'
    distinct: List['LicenseScalarFieldKeys']
    include: 'LicenseIncludeFromLicense'


class TenantIncludeFromAgent(TypedDict, total=False):
    """Relational arguments for Agent"""
    users: Union[bool, 'FindManyUserArgsFromAgent']
    projects: Union[bool, 'FindManyProjectArgsFromAgent']
    jobs: Union[bool, 'FindManyJobArgsFromAgent']
    agents: Union[bool, 'FindManyAgentArgsFromAgent']
    candidates: Union[bool, 'FindManyCandidateArgsFromAgent']
    license: Union[bool, 'LicenseArgsFromAgent']


class TenantArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class UserRoleIncludeFromAgent(TypedDict, total=False):
    """Relational arguments for Agent"""
    users: Union[bool, 'FindManyUserArgsFromAgent']


class UserRoleArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    include: 'UserRoleIncludeFromUserRole'


class FindManyUserRoleArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    take: int
    skip: int
    order_by: Union['UserRoleOrderByInput', List['UserRoleOrderByInput']]
    where: 'UserRoleWhereInput'
    cursor: 'UserRoleWhereUniqueInput'
    distinct: List['UserRoleScalarFieldKeys']
    include: 'UserRoleIncludeFromUserRole'


class UserIncludeFromAgent(TypedDict, total=False):
    """Relational arguments for Agent"""
    role: Union[bool, 'UserRoleArgsFromAgent']
    tenant: Union[bool, 'TenantArgsFromAgent']
    projects: Union[bool, 'FindManyProjectArgsFromAgent']
    sessions: Union[bool, 'FindManyUserSessionArgsFromAgent']


class UserArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserSessionIncludeFromAgent(TypedDict, total=False):
    """Relational arguments for Agent"""
    user: Union[bool, 'UserArgsFromAgent']


class UserSessionArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    include: 'UserSessionIncludeFromUserSession'


class FindManyUserSessionArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    take: int
    skip: int
    order_by: Union['UserSessionOrderByInput', List['UserSessionOrderByInput']]
    where: 'UserSessionWhereInput'
    cursor: 'UserSessionWhereUniqueInput'
    distinct: List['UserSessionScalarFieldKeys']
    include: 'UserSessionIncludeFromUserSession'


class CandidateIncludeFromAgent(TypedDict, total=False):
    """Relational arguments for Agent"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromAgent']
    tenant: Union[bool, 'TenantArgsFromAgent']


class CandidateArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    include: 'CandidateIncludeFromCandidate'


class FindManyCandidateArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidate'


class JobIncludeFromAgent(TypedDict, total=False):
    """Relational arguments for Agent"""
    tenant: Union[bool, 'TenantArgsFromAgent']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromAgent']


class JobArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    include: 'JobIncludeFromJob'


class FindManyJobArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJob'


class JobCandidateIncludeFromAgent(TypedDict, total=False):
    """Relational arguments for Agent"""
    job: Union[bool, 'JobArgsFromAgent']
    candidate: Union[bool, 'CandidateArgsFromAgent']


class JobCandidateArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    include: 'JobCandidateIncludeFromJobCandidate'


class FindManyJobCandidateArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    take: int
    skip: int
    order_by: Union['JobCandidateOrderByInput', List['JobCandidateOrderByInput']]
    where: 'JobCandidateWhereInput'
    cursor: 'JobCandidateWhereUniqueInput'
    distinct: List['JobCandidateScalarFieldKeys']
    include: 'JobCandidateIncludeFromJobCandidate'


class ProjectIncludeFromAgent(TypedDict, total=False):
    """Relational arguments for Agent"""
    tenant: Union[bool, 'TenantArgsFromAgent']
    user: Union[bool, 'UserArgsFromAgent']


class ProjectArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    include: 'ProjectIncludeFromProject'


class FindManyProjectArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProject'


class AgentIncludeFromAgent(TypedDict, total=False):
    """Relational arguments for Agent"""
    tenant: Union[bool, 'TenantArgsFromAgent']
    conversations: Union[bool, 'FindManyConversationArgsFromAgent']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromAgent']


class AgentArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    include: 'AgentIncludeFromAgent'


class FindManyAgentArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    take: int
    skip: int
    order_by: Union['AgentOrderByInput', List['AgentOrderByInput']]
    where: 'AgentWhereInput'
    cursor: 'AgentWhereUniqueInput'
    distinct: List['AgentScalarFieldKeys']
    include: 'AgentIncludeFromAgent'


class ConversationIncludeFromAgent(TypedDict, total=False):
    """Relational arguments for Agent"""
    agent: Union[bool, 'AgentArgsFromAgent']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromAgent']


class ConversationArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    include: 'ConversationIncludeFromConversation'


class FindManyConversationArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversation'


class AgentTaskIncludeFromAgent(TypedDict, total=False):
    """Relational arguments for Agent"""
    agent: Union[bool, 'AgentArgsFromAgent']
    conversation: Union[bool, 'ConversationArgsFromAgent']


class AgentTaskArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    include: 'AgentTaskIncludeFromAgentTask'


class FindManyAgentTaskArgsFromAgent(TypedDict, total=False):
    """Arguments for Agent"""
    take: int
    skip: int
    order_by: Union['AgentTaskOrderByInput', List['AgentTaskOrderByInput']]
    where: 'AgentTaskWhereInput'
    cursor: 'AgentTaskWhereUniqueInput'
    distinct: List['AgentTaskScalarFieldKeys']
    include: 'AgentTaskIncludeFromAgentTask'




FindManyAgentArgs = FindManyAgentArgsFromAgent
FindFirstAgentArgs = FindManyAgentArgsFromAgent


class AgentWhereInput(TypedDict, total=False):
    """Agent arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    type: 'enums.AgentType'
    prompt: Union[None, _str, 'types.StringFilter']
    temperature: Union[None, _float, 'types.FloatFilter']
    maxTokens: Union[None, _int, 'types.IntFilter']
    topP: Union[None, _float, 'types.FloatFilter']
    frequencyPenalty: Union[None, _float, 'types.FloatFilter']
    presencePenalty: Union[None, _float, 'types.FloatFilter']
    stopSequence: 'types.StringListFilter'
    stopSequenceTokens: 'types.StringListFilter'
    config: Union[None, 'fields.Json', 'types.JsonFilter']
    tenantId: Union[_str, 'types.StringFilter']
    tenant: 'TenantRelationFilter'
    conversations: 'ConversationListRelationFilter'
    agentTasks: 'AgentTaskListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['AgentWhereInput', List['AgentWhereInput']]
    # but this causes mypy to hang :/
    AND: List['AgentWhereInput']
    OR: List['AgentWhereInput']
    NOT: List['AgentWhereInput']



# aggregate Agent types


class AgentScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Agent arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    type: 'enums.AgentType'
    prompt: Union[_str, 'types.StringWithAggregatesFilter']
    temperature: Union[_float, 'types.FloatWithAggregatesFilter']
    maxTokens: Union[_int, 'types.IntWithAggregatesFilter']
    topP: Union[_float, 'types.FloatWithAggregatesFilter']
    frequencyPenalty: Union[_float, 'types.FloatWithAggregatesFilter']
    presencePenalty: Union[_float, 'types.FloatWithAggregatesFilter']
    stopSequence: Union[_str, 'types.StringWithAggregatesFilter']
    stopSequenceTokens: Union[_str, 'types.StringWithAggregatesFilter']
    config: Union['fields.Json', 'types.JsonWithAggregatesFilter']
    tenantId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AgentScalarWhereWithAggregatesInput']
    OR: List['AgentScalarWhereWithAggregatesInput']
    NOT: List['AgentScalarWhereWithAggregatesInput']



class AgentGroupByOutput(TypedDict, total=False):
    id: _str
    name: _str
    description: _str
    type: 'enums.AgentType'
    prompt: _str
    temperature: _float
    maxTokens: _int
    topP: _float
    frequencyPenalty: _float
    presencePenalty: _float
    stopSequence: List[_str]
    stopSequenceTokens: List[_str]
    config: 'fields.Json'
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime
    _sum: 'AgentSumAggregateOutput'
    _avg: 'AgentAvgAggregateOutput'
    _min: 'AgentMinAggregateOutput'
    _max: 'AgentMaxAggregateOutput'
    _count: 'AgentCountAggregateOutput'


class AgentAvgAggregateOutput(TypedDict, total=False):
    """Agent output for aggregating averages"""
    temperature: float
    maxTokens: float
    topP: float
    frequencyPenalty: float
    presencePenalty: float


class AgentSumAggregateOutput(TypedDict, total=False):
    """Agent output for aggregating sums"""
    temperature: _float
    maxTokens: _int
    topP: _float
    frequencyPenalty: _float
    presencePenalty: _float


class AgentScalarAggregateOutput(TypedDict, total=False):
    """Agent output including scalar fields"""
    id: _str
    name: _str
    description: _str
    type: 'enums.AgentType'
    prompt: _str
    temperature: _float
    maxTokens: _int
    topP: _float
    frequencyPenalty: _float
    presencePenalty: _float
    stopSequence: List[_str]
    stopSequenceTokens: List[_str]
    config: 'fields.Json'
    tenantId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime


AgentMinAggregateOutput = AgentScalarAggregateOutput
AgentMaxAggregateOutput = AgentScalarAggregateOutput


class AgentMaxAggregateInput(TypedDict, total=False):
    """Agent input for aggregating by max"""
    id: bool
    name: bool
    description: bool
    type: bool
    prompt: bool
    temperature: bool
    maxTokens: bool
    topP: bool
    frequencyPenalty: bool
    presencePenalty: bool
    stopSequence: bool
    stopSequenceTokens: bool
    config: bool
    tenantId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class AgentMinAggregateInput(TypedDict, total=False):
    """Agent input for aggregating by min"""
    id: bool
    name: bool
    description: bool
    type: bool
    prompt: bool
    temperature: bool
    maxTokens: bool
    topP: bool
    frequencyPenalty: bool
    presencePenalty: bool
    stopSequence: bool
    stopSequenceTokens: bool
    config: bool
    tenantId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class AgentNumberAggregateInput(TypedDict, total=False):
    """Agent input for aggregating numbers"""
    temperature: bool
    maxTokens: bool
    topP: bool
    frequencyPenalty: bool
    presencePenalty: bool


AgentAvgAggregateInput = AgentNumberAggregateInput
AgentSumAggregateInput = AgentNumberAggregateInput


AgentCountAggregateInput = TypedDict(
    'AgentCountAggregateInput',
    {
        'id': bool,
        'name': bool,
        'description': bool,
        'type': bool,
        'prompt': bool,
        'temperature': bool,
        'maxTokens': bool,
        'topP': bool,
        'frequencyPenalty': bool,
        'presencePenalty': bool,
        'stopSequence': bool,
        'stopSequenceTokens': bool,
        'config': bool,
        'tenantId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deleted': bool,
        'deletedAt': bool,
        '_all': bool,
    },
    total=False,
)

AgentCountAggregateOutput = TypedDict(
    'AgentCountAggregateOutput',
    {
        'id': int,
        'name': int,
        'description': int,
        'type': int,
        'prompt': int,
        'temperature': int,
        'maxTokens': int,
        'topP': int,
        'frequencyPenalty': int,
        'presencePenalty': int,
        'stopSequence': int,
        'stopSequenceTokens': int,
        'config': int,
        'tenantId': int,
        'createdAt': int,
        'updatedAt': int,
        'deleted': int,
        'deletedAt': int,
        '_all': int,
    },
    total=False,
)


AgentKeys = Literal[
    'id',
    'name',
    'description',
    'type',
    'prompt',
    'temperature',
    'maxTokens',
    'topP',
    'frequencyPenalty',
    'presencePenalty',
    'stopSequence',
    'stopSequenceTokens',
    'config',
    'tenantId',
    'tenant',
    'conversations',
    'agentTasks',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
AgentScalarFieldKeys = Literal[
    'id',
    'name',
    'description',
    'type',
    'prompt',
    'temperature',
    'maxTokens',
    'topP',
    'frequencyPenalty',
    'presencePenalty',
    'stopSequence',
    'stopSequenceTokens',
    'config',
    'tenantId',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
AgentScalarFieldKeysT = TypeVar('AgentScalarFieldKeysT', bound=AgentScalarFieldKeys)

AgentRelationalFieldKeys = Literal[
        'tenant',
        'conversations',
        'agentTasks',
    ]

# Conversation types

class ConversationOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Conversation create method"""
    id: _str
    agentId: _str
    agent: 'AgentCreateNestedWithoutRelationsInput'
    agentTasks: 'AgentTaskCreateManyNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class ConversationCreateInput(ConversationOptionalCreateInput):
    """Required arguments to the Conversation create method"""


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class ConversationOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Conversation create method, without relations"""
    id: _str
    agentId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class ConversationCreateWithoutRelationsInput(ConversationOptionalCreateWithoutRelationsInput):
    """Required arguments to the Conversation create method, without relations"""

class ConversationConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'ConversationCreateWithoutRelationsInput'
    where: 'ConversationWhereUniqueInput'

class ConversationCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'ConversationCreateWithoutRelationsInput'
    connect: 'ConversationWhereUniqueInput'
    connect_or_create: 'ConversationConnectOrCreateWithoutRelationsInput'


class ConversationCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['ConversationCreateWithoutRelationsInput', List['ConversationCreateWithoutRelationsInput']]
    connect: Union['ConversationWhereUniqueInput', List['ConversationWhereUniqueInput']]
    connect_or_create: Union['ConversationConnectOrCreateWithoutRelationsInput', List['ConversationConnectOrCreateWithoutRelationsInput']]

_ConversationWhereUnique_id_Input = TypedDict(
    '_ConversationWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

ConversationWhereUniqueInput = _ConversationWhereUnique_id_Input


class ConversationUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    agent: 'AgentUpdateOneWithoutRelationsInput'
    agentTasks: 'AgentTaskUpdateManyWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class ConversationUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class ConversationUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['ConversationCreateWithoutRelationsInput']
    connect: List['ConversationWhereUniqueInput']
    connect_or_create: List['ConversationConnectOrCreateWithoutRelationsInput']
    set: List['ConversationWhereUniqueInput']
    disconnect: List['ConversationWhereUniqueInput']
    delete: List['ConversationWhereUniqueInput']

    # TODO
    # update: List['ConversationUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['ConversationUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['ConversationScalarWhereInput']
    # upsert: List['ConversationUpserteWithWhereUniqueWithoutRelationsInput']


class ConversationUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'ConversationCreateWithoutRelationsInput'
    connect: 'ConversationWhereUniqueInput'
    connect_or_create: 'ConversationConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'ConversationUpdateInput'
    # upsert: 'ConversationUpsertWithoutRelationsInput'


class ConversationUpsertInput(TypedDict):
    create: 'ConversationCreateInput'
    update: 'ConversationUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Conversation_id_OrderByInput = TypedDict(
    '_Conversation_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Conversation_agentId_OrderByInput = TypedDict(
    '_Conversation_agentId_OrderByInput',
    {
        'agentId': 'SortOrder',
    },
    total=True
)

_Conversation_createdAt_OrderByInput = TypedDict(
    '_Conversation_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_Conversation_updatedAt_OrderByInput = TypedDict(
    '_Conversation_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_Conversation_deleted_OrderByInput = TypedDict(
    '_Conversation_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_Conversation_deletedAt_OrderByInput = TypedDict(
    '_Conversation_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_Conversation_RelevanceInner = TypedDict(
    '_Conversation_RelevanceInner',
    {
        'fields': 'List[ConversationScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_Conversation_RelevanceOrderByInput = TypedDict(
    '_Conversation_RelevanceOrderByInput',
    {
        '_relevance': '_Conversation_RelevanceInner',
    },
    total=True
)

ConversationOrderByInput = Union[
    '_Conversation_id_OrderByInput',
    '_Conversation_agentId_OrderByInput',
    '_Conversation_createdAt_OrderByInput',
    '_Conversation_updatedAt_OrderByInput',
    '_Conversation_deleted_OrderByInput',
    '_Conversation_deletedAt_OrderByInput',
    '_Conversation_RelevanceOrderByInput',
]



# recursive Conversation types
# TODO: cleanup these types



ConversationRelationFilter = TypedDict(
    'ConversationRelationFilter',
    {
        'is': 'ConversationWhereInput',
        'is_not': 'ConversationWhereInput',
    },
    total=False,
)


class ConversationListRelationFilter(TypedDict, total=False):
    some: 'ConversationWhereInput'
    none: 'ConversationWhereInput'
    every: 'ConversationWhereInput'


class ConversationInclude(TypedDict, total=False):
    """Conversation relational arguments"""
    agent: Union[bool, 'AgentArgsFromConversation']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromConversation']


class LicenseIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    tenants: Union[bool, 'FindManyTenantArgsFromConversation']


class LicenseArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'LicenseIncludeFromLicense'


class FindManyLicenseArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['LicenseOrderByInput', List['LicenseOrderByInput']]
    where: 'LicenseWhereInput'
    cursor: 'LicenseWhereUniqueInput'
    distinct: List['LicenseScalarFieldKeys']
    include: 'LicenseIncludeFromLicense'


class TenantIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    users: Union[bool, 'FindManyUserArgsFromConversation']
    projects: Union[bool, 'FindManyProjectArgsFromConversation']
    jobs: Union[bool, 'FindManyJobArgsFromConversation']
    agents: Union[bool, 'FindManyAgentArgsFromConversation']
    candidates: Union[bool, 'FindManyCandidateArgsFromConversation']
    license: Union[bool, 'LicenseArgsFromConversation']


class TenantArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class UserRoleIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    users: Union[bool, 'FindManyUserArgsFromConversation']


class UserRoleArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'UserRoleIncludeFromUserRole'


class FindManyUserRoleArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['UserRoleOrderByInput', List['UserRoleOrderByInput']]
    where: 'UserRoleWhereInput'
    cursor: 'UserRoleWhereUniqueInput'
    distinct: List['UserRoleScalarFieldKeys']
    include: 'UserRoleIncludeFromUserRole'


class UserIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    role: Union[bool, 'UserRoleArgsFromConversation']
    tenant: Union[bool, 'TenantArgsFromConversation']
    projects: Union[bool, 'FindManyProjectArgsFromConversation']
    sessions: Union[bool, 'FindManyUserSessionArgsFromConversation']


class UserArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserSessionIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    user: Union[bool, 'UserArgsFromConversation']


class UserSessionArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'UserSessionIncludeFromUserSession'


class FindManyUserSessionArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['UserSessionOrderByInput', List['UserSessionOrderByInput']]
    where: 'UserSessionWhereInput'
    cursor: 'UserSessionWhereUniqueInput'
    distinct: List['UserSessionScalarFieldKeys']
    include: 'UserSessionIncludeFromUserSession'


class CandidateIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromConversation']
    tenant: Union[bool, 'TenantArgsFromConversation']


class CandidateArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'CandidateIncludeFromCandidate'


class FindManyCandidateArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidate'


class JobIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    tenant: Union[bool, 'TenantArgsFromConversation']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromConversation']


class JobArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'JobIncludeFromJob'


class FindManyJobArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJob'


class JobCandidateIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    job: Union[bool, 'JobArgsFromConversation']
    candidate: Union[bool, 'CandidateArgsFromConversation']


class JobCandidateArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'JobCandidateIncludeFromJobCandidate'


class FindManyJobCandidateArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['JobCandidateOrderByInput', List['JobCandidateOrderByInput']]
    where: 'JobCandidateWhereInput'
    cursor: 'JobCandidateWhereUniqueInput'
    distinct: List['JobCandidateScalarFieldKeys']
    include: 'JobCandidateIncludeFromJobCandidate'


class ProjectIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    tenant: Union[bool, 'TenantArgsFromConversation']
    user: Union[bool, 'UserArgsFromConversation']


class ProjectArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'ProjectIncludeFromProject'


class FindManyProjectArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProject'


class AgentIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    tenant: Union[bool, 'TenantArgsFromConversation']
    conversations: Union[bool, 'FindManyConversationArgsFromConversation']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromConversation']


class AgentArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'AgentIncludeFromAgent'


class FindManyAgentArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['AgentOrderByInput', List['AgentOrderByInput']]
    where: 'AgentWhereInput'
    cursor: 'AgentWhereUniqueInput'
    distinct: List['AgentScalarFieldKeys']
    include: 'AgentIncludeFromAgent'


class ConversationIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    agent: Union[bool, 'AgentArgsFromConversation']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromConversation']


class ConversationArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'ConversationIncludeFromConversation'


class FindManyConversationArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversation'


class AgentTaskIncludeFromConversation(TypedDict, total=False):
    """Relational arguments for Conversation"""
    agent: Union[bool, 'AgentArgsFromConversation']
    conversation: Union[bool, 'ConversationArgsFromConversation']


class AgentTaskArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    include: 'AgentTaskIncludeFromAgentTask'


class FindManyAgentTaskArgsFromConversation(TypedDict, total=False):
    """Arguments for Conversation"""
    take: int
    skip: int
    order_by: Union['AgentTaskOrderByInput', List['AgentTaskOrderByInput']]
    where: 'AgentTaskWhereInput'
    cursor: 'AgentTaskWhereUniqueInput'
    distinct: List['AgentTaskScalarFieldKeys']
    include: 'AgentTaskIncludeFromAgentTask'




FindManyConversationArgs = FindManyConversationArgsFromConversation
FindFirstConversationArgs = FindManyConversationArgsFromConversation


class ConversationWhereInput(TypedDict, total=False):
    """Conversation arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    agentId: Union[_str, 'types.StringFilter']
    agent: 'AgentRelationFilter'
    agentTasks: 'AgentTaskListRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['ConversationWhereInput', List['ConversationWhereInput']]
    # but this causes mypy to hang :/
    AND: List['ConversationWhereInput']
    OR: List['ConversationWhereInput']
    NOT: List['ConversationWhereInput']



# aggregate Conversation types


class ConversationScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Conversation arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    agentId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['ConversationScalarWhereWithAggregatesInput']
    OR: List['ConversationScalarWhereWithAggregatesInput']
    NOT: List['ConversationScalarWhereWithAggregatesInput']



class ConversationGroupByOutput(TypedDict, total=False):
    id: _str
    agentId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime
    _sum: 'ConversationSumAggregateOutput'
    _avg: 'ConversationAvgAggregateOutput'
    _min: 'ConversationMinAggregateOutput'
    _max: 'ConversationMaxAggregateOutput'
    _count: 'ConversationCountAggregateOutput'


class ConversationAvgAggregateOutput(TypedDict, total=False):
    """Conversation output for aggregating averages"""


class ConversationSumAggregateOutput(TypedDict, total=False):
    """Conversation output for aggregating sums"""


class ConversationScalarAggregateOutput(TypedDict, total=False):
    """Conversation output including scalar fields"""
    id: _str
    agentId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime


ConversationMinAggregateOutput = ConversationScalarAggregateOutput
ConversationMaxAggregateOutput = ConversationScalarAggregateOutput


class ConversationMaxAggregateInput(TypedDict, total=False):
    """Conversation input for aggregating by max"""
    id: bool
    agentId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class ConversationMinAggregateInput(TypedDict, total=False):
    """Conversation input for aggregating by min"""
    id: bool
    agentId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class ConversationNumberAggregateInput(TypedDict, total=False):
    """Conversation input for aggregating numbers"""


ConversationAvgAggregateInput = ConversationNumberAggregateInput
ConversationSumAggregateInput = ConversationNumberAggregateInput


ConversationCountAggregateInput = TypedDict(
    'ConversationCountAggregateInput',
    {
        'id': bool,
        'agentId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deleted': bool,
        'deletedAt': bool,
        '_all': bool,
    },
    total=False,
)

ConversationCountAggregateOutput = TypedDict(
    'ConversationCountAggregateOutput',
    {
        'id': int,
        'agentId': int,
        'createdAt': int,
        'updatedAt': int,
        'deleted': int,
        'deletedAt': int,
        '_all': int,
    },
    total=False,
)


ConversationKeys = Literal[
    'id',
    'agentId',
    'agent',
    'agentTasks',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
ConversationScalarFieldKeys = Literal[
    'id',
    'agentId',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
ConversationScalarFieldKeysT = TypeVar('ConversationScalarFieldKeysT', bound=ConversationScalarFieldKeys)

ConversationRelationalFieldKeys = Literal[
        'agent',
        'agentTasks',
    ]

# AgentTask types

class AgentTaskOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the AgentTask create method"""
    id: _str
    agentId: _str
    agent: 'AgentCreateNestedWithoutRelationsInput'
    description: Optional[_str]
    conversationId: _str
    conversation: 'ConversationCreateNestedWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class AgentTaskCreateInput(AgentTaskOptionalCreateInput):
    """Required arguments to the AgentTask create method"""
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class AgentTaskOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the AgentTask create method, without relations"""
    id: _str
    agentId: _str
    description: Optional[_str]
    conversationId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class AgentTaskCreateWithoutRelationsInput(AgentTaskOptionalCreateWithoutRelationsInput):
    """Required arguments to the AgentTask create method, without relations"""
    name: _str

class AgentTaskConnectOrCreateWithoutRelationsInput(TypedDict):
    create: 'AgentTaskCreateWithoutRelationsInput'
    where: 'AgentTaskWhereUniqueInput'

class AgentTaskCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'AgentTaskCreateWithoutRelationsInput'
    connect: 'AgentTaskWhereUniqueInput'
    connect_or_create: 'AgentTaskConnectOrCreateWithoutRelationsInput'


class AgentTaskCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['AgentTaskCreateWithoutRelationsInput', List['AgentTaskCreateWithoutRelationsInput']]
    connect: Union['AgentTaskWhereUniqueInput', List['AgentTaskWhereUniqueInput']]
    connect_or_create: Union['AgentTaskConnectOrCreateWithoutRelationsInput', List['AgentTaskConnectOrCreateWithoutRelationsInput']]

_AgentTaskWhereUnique_id_Input = TypedDict(
    '_AgentTaskWhereUnique_id_Input',
    {
        'id': '_str',
    },
    total=True
)

AgentTaskWhereUniqueInput = _AgentTaskWhereUnique_id_Input


class AgentTaskUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: _str
    agent: 'AgentUpdateOneWithoutRelationsInput'
    name: _str
    description: Optional[_str]
    conversation: 'ConversationUpdateOneWithoutRelationsInput'
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class AgentTaskUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: _str
    name: _str
    description: Optional[_str]
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: Optional[datetime.datetime]


class AgentTaskUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['AgentTaskCreateWithoutRelationsInput']
    connect: List['AgentTaskWhereUniqueInput']
    connect_or_create: List['AgentTaskConnectOrCreateWithoutRelationsInput']
    set: List['AgentTaskWhereUniqueInput']
    disconnect: List['AgentTaskWhereUniqueInput']
    delete: List['AgentTaskWhereUniqueInput']

    # TODO
    # update: List['AgentTaskUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['AgentTaskUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['AgentTaskScalarWhereInput']
    # upsert: List['AgentTaskUpserteWithWhereUniqueWithoutRelationsInput']


class AgentTaskUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'AgentTaskCreateWithoutRelationsInput'
    connect: 'AgentTaskWhereUniqueInput'
    connect_or_create: 'AgentTaskConnectOrCreateWithoutRelationsInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'AgentTaskUpdateInput'
    # upsert: 'AgentTaskUpsertWithoutRelationsInput'


class AgentTaskUpsertInput(TypedDict):
    create: 'AgentTaskCreateInput'
    update: 'AgentTaskUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_AgentTask_id_OrderByInput = TypedDict(
    '_AgentTask_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_AgentTask_agentId_OrderByInput = TypedDict(
    '_AgentTask_agentId_OrderByInput',
    {
        'agentId': 'SortOrder',
    },
    total=True
)

_AgentTask_name_OrderByInput = TypedDict(
    '_AgentTask_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_AgentTask_description_OrderByInput = TypedDict(
    '_AgentTask_description_OrderByInput',
    {
        'description': 'SortOrder',
    },
    total=True
)

_AgentTask_conversationId_OrderByInput = TypedDict(
    '_AgentTask_conversationId_OrderByInput',
    {
        'conversationId': 'SortOrder',
    },
    total=True
)

_AgentTask_createdAt_OrderByInput = TypedDict(
    '_AgentTask_createdAt_OrderByInput',
    {
        'createdAt': 'SortOrder',
    },
    total=True
)

_AgentTask_updatedAt_OrderByInput = TypedDict(
    '_AgentTask_updatedAt_OrderByInput',
    {
        'updatedAt': 'SortOrder',
    },
    total=True
)

_AgentTask_deleted_OrderByInput = TypedDict(
    '_AgentTask_deleted_OrderByInput',
    {
        'deleted': 'SortOrder',
    },
    total=True
)

_AgentTask_deletedAt_OrderByInput = TypedDict(
    '_AgentTask_deletedAt_OrderByInput',
    {
        'deletedAt': 'SortOrder',
    },
    total=True
)

_AgentTask_RelevanceInner = TypedDict(
    '_AgentTask_RelevanceInner',
    {
        'fields': 'List[AgentTaskScalarFieldKeys]',
        'search': 'str',
        'sort': 'SortOrder',
    },
    total=True
)

_AgentTask_RelevanceOrderByInput = TypedDict(
    '_AgentTask_RelevanceOrderByInput',
    {
        '_relevance': '_AgentTask_RelevanceInner',
    },
    total=True
)

AgentTaskOrderByInput = Union[
    '_AgentTask_id_OrderByInput',
    '_AgentTask_agentId_OrderByInput',
    '_AgentTask_name_OrderByInput',
    '_AgentTask_description_OrderByInput',
    '_AgentTask_conversationId_OrderByInput',
    '_AgentTask_createdAt_OrderByInput',
    '_AgentTask_updatedAt_OrderByInput',
    '_AgentTask_deleted_OrderByInput',
    '_AgentTask_deletedAt_OrderByInput',
    '_AgentTask_RelevanceOrderByInput',
]



# recursive AgentTask types
# TODO: cleanup these types



AgentTaskRelationFilter = TypedDict(
    'AgentTaskRelationFilter',
    {
        'is': 'AgentTaskWhereInput',
        'is_not': 'AgentTaskWhereInput',
    },
    total=False,
)


class AgentTaskListRelationFilter(TypedDict, total=False):
    some: 'AgentTaskWhereInput'
    none: 'AgentTaskWhereInput'
    every: 'AgentTaskWhereInput'


class AgentTaskInclude(TypedDict, total=False):
    """AgentTask relational arguments"""
    agent: Union[bool, 'AgentArgsFromAgentTask']
    conversation: Union[bool, 'ConversationArgsFromAgentTask']


class LicenseIncludeFromAgentTask(TypedDict, total=False):
    """Relational arguments for AgentTask"""
    tenants: Union[bool, 'FindManyTenantArgsFromAgentTask']


class LicenseArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    include: 'LicenseIncludeFromLicense'


class FindManyLicenseArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    take: int
    skip: int
    order_by: Union['LicenseOrderByInput', List['LicenseOrderByInput']]
    where: 'LicenseWhereInput'
    cursor: 'LicenseWhereUniqueInput'
    distinct: List['LicenseScalarFieldKeys']
    include: 'LicenseIncludeFromLicense'


class TenantIncludeFromAgentTask(TypedDict, total=False):
    """Relational arguments for AgentTask"""
    users: Union[bool, 'FindManyUserArgsFromAgentTask']
    projects: Union[bool, 'FindManyProjectArgsFromAgentTask']
    jobs: Union[bool, 'FindManyJobArgsFromAgentTask']
    agents: Union[bool, 'FindManyAgentArgsFromAgentTask']
    candidates: Union[bool, 'FindManyCandidateArgsFromAgentTask']
    license: Union[bool, 'LicenseArgsFromAgentTask']


class TenantArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    include: 'TenantIncludeFromTenant'


class FindManyTenantArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    take: int
    skip: int
    order_by: Union['TenantOrderByInput', List['TenantOrderByInput']]
    where: 'TenantWhereInput'
    cursor: 'TenantWhereUniqueInput'
    distinct: List['TenantScalarFieldKeys']
    include: 'TenantIncludeFromTenant'


class UserRoleIncludeFromAgentTask(TypedDict, total=False):
    """Relational arguments for AgentTask"""
    users: Union[bool, 'FindManyUserArgsFromAgentTask']


class UserRoleArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    include: 'UserRoleIncludeFromUserRole'


class FindManyUserRoleArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    take: int
    skip: int
    order_by: Union['UserRoleOrderByInput', List['UserRoleOrderByInput']]
    where: 'UserRoleWhereInput'
    cursor: 'UserRoleWhereUniqueInput'
    distinct: List['UserRoleScalarFieldKeys']
    include: 'UserRoleIncludeFromUserRole'


class UserIncludeFromAgentTask(TypedDict, total=False):
    """Relational arguments for AgentTask"""
    role: Union[bool, 'UserRoleArgsFromAgentTask']
    tenant: Union[bool, 'TenantArgsFromAgentTask']
    projects: Union[bool, 'FindManyProjectArgsFromAgentTask']
    sessions: Union[bool, 'FindManyUserSessionArgsFromAgentTask']


class UserArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    include: 'UserIncludeFromUser'


class FindManyUserArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    take: int
    skip: int
    order_by: Union['UserOrderByInput', List['UserOrderByInput']]
    where: 'UserWhereInput'
    cursor: 'UserWhereUniqueInput'
    distinct: List['UserScalarFieldKeys']
    include: 'UserIncludeFromUser'


class UserSessionIncludeFromAgentTask(TypedDict, total=False):
    """Relational arguments for AgentTask"""
    user: Union[bool, 'UserArgsFromAgentTask']


class UserSessionArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    include: 'UserSessionIncludeFromUserSession'


class FindManyUserSessionArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    take: int
    skip: int
    order_by: Union['UserSessionOrderByInput', List['UserSessionOrderByInput']]
    where: 'UserSessionWhereInput'
    cursor: 'UserSessionWhereUniqueInput'
    distinct: List['UserSessionScalarFieldKeys']
    include: 'UserSessionIncludeFromUserSession'


class CandidateIncludeFromAgentTask(TypedDict, total=False):
    """Relational arguments for AgentTask"""
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromAgentTask']
    tenant: Union[bool, 'TenantArgsFromAgentTask']


class CandidateArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    include: 'CandidateIncludeFromCandidate'


class FindManyCandidateArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    take: int
    skip: int
    order_by: Union['CandidateOrderByInput', List['CandidateOrderByInput']]
    where: 'CandidateWhereInput'
    cursor: 'CandidateWhereUniqueInput'
    distinct: List['CandidateScalarFieldKeys']
    include: 'CandidateIncludeFromCandidate'


class JobIncludeFromAgentTask(TypedDict, total=False):
    """Relational arguments for AgentTask"""
    tenant: Union[bool, 'TenantArgsFromAgentTask']
    jobCandidates: Union[bool, 'FindManyJobCandidateArgsFromAgentTask']


class JobArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    include: 'JobIncludeFromJob'


class FindManyJobArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    take: int
    skip: int
    order_by: Union['JobOrderByInput', List['JobOrderByInput']]
    where: 'JobWhereInput'
    cursor: 'JobWhereUniqueInput'
    distinct: List['JobScalarFieldKeys']
    include: 'JobIncludeFromJob'


class JobCandidateIncludeFromAgentTask(TypedDict, total=False):
    """Relational arguments for AgentTask"""
    job: Union[bool, 'JobArgsFromAgentTask']
    candidate: Union[bool, 'CandidateArgsFromAgentTask']


class JobCandidateArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    include: 'JobCandidateIncludeFromJobCandidate'


class FindManyJobCandidateArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    take: int
    skip: int
    order_by: Union['JobCandidateOrderByInput', List['JobCandidateOrderByInput']]
    where: 'JobCandidateWhereInput'
    cursor: 'JobCandidateWhereUniqueInput'
    distinct: List['JobCandidateScalarFieldKeys']
    include: 'JobCandidateIncludeFromJobCandidate'


class ProjectIncludeFromAgentTask(TypedDict, total=False):
    """Relational arguments for AgentTask"""
    tenant: Union[bool, 'TenantArgsFromAgentTask']
    user: Union[bool, 'UserArgsFromAgentTask']


class ProjectArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    include: 'ProjectIncludeFromProject'


class FindManyProjectArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    take: int
    skip: int
    order_by: Union['ProjectOrderByInput', List['ProjectOrderByInput']]
    where: 'ProjectWhereInput'
    cursor: 'ProjectWhereUniqueInput'
    distinct: List['ProjectScalarFieldKeys']
    include: 'ProjectIncludeFromProject'


class AgentIncludeFromAgentTask(TypedDict, total=False):
    """Relational arguments for AgentTask"""
    tenant: Union[bool, 'TenantArgsFromAgentTask']
    conversations: Union[bool, 'FindManyConversationArgsFromAgentTask']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromAgentTask']


class AgentArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    include: 'AgentIncludeFromAgent'


class FindManyAgentArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    take: int
    skip: int
    order_by: Union['AgentOrderByInput', List['AgentOrderByInput']]
    where: 'AgentWhereInput'
    cursor: 'AgentWhereUniqueInput'
    distinct: List['AgentScalarFieldKeys']
    include: 'AgentIncludeFromAgent'


class ConversationIncludeFromAgentTask(TypedDict, total=False):
    """Relational arguments for AgentTask"""
    agent: Union[bool, 'AgentArgsFromAgentTask']
    agentTasks: Union[bool, 'FindManyAgentTaskArgsFromAgentTask']


class ConversationArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    include: 'ConversationIncludeFromConversation'


class FindManyConversationArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    take: int
    skip: int
    order_by: Union['ConversationOrderByInput', List['ConversationOrderByInput']]
    where: 'ConversationWhereInput'
    cursor: 'ConversationWhereUniqueInput'
    distinct: List['ConversationScalarFieldKeys']
    include: 'ConversationIncludeFromConversation'


class AgentTaskIncludeFromAgentTask(TypedDict, total=False):
    """Relational arguments for AgentTask"""
    agent: Union[bool, 'AgentArgsFromAgentTask']
    conversation: Union[bool, 'ConversationArgsFromAgentTask']


class AgentTaskArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    include: 'AgentTaskIncludeFromAgentTask'


class FindManyAgentTaskArgsFromAgentTask(TypedDict, total=False):
    """Arguments for AgentTask"""
    take: int
    skip: int
    order_by: Union['AgentTaskOrderByInput', List['AgentTaskOrderByInput']]
    where: 'AgentTaskWhereInput'
    cursor: 'AgentTaskWhereUniqueInput'
    distinct: List['AgentTaskScalarFieldKeys']
    include: 'AgentTaskIncludeFromAgentTask'




FindManyAgentTaskArgs = FindManyAgentTaskArgsFromAgentTask
FindFirstAgentTaskArgs = FindManyAgentTaskArgsFromAgentTask


class AgentTaskWhereInput(TypedDict, total=False):
    """AgentTask arguments for searching"""
    id: Union[_str, 'types.StringFilter']
    agentId: Union[_str, 'types.StringFilter']
    agent: 'AgentRelationFilter'
    name: Union[_str, 'types.StringFilter']
    description: Union[None, _str, 'types.StringFilter']
    conversationId: Union[_str, 'types.StringFilter']
    conversation: 'ConversationRelationFilter'
    createdAt: Union[datetime.datetime, 'types.DateTimeFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeFilter']
    deleted: Union[_bool, 'types.BooleanFilter']
    deletedAt: Union[None, datetime.datetime, 'types.DateTimeFilter']

    # should be noted that AND and NOT should be Union['AgentTaskWhereInput', List['AgentTaskWhereInput']]
    # but this causes mypy to hang :/
    AND: List['AgentTaskWhereInput']
    OR: List['AgentTaskWhereInput']
    NOT: List['AgentTaskWhereInput']



# aggregate AgentTask types


class AgentTaskScalarWhereWithAggregatesInput(TypedDict, total=False):
    """AgentTask arguments for searching"""
    id: Union[_str, 'types.StringWithAggregatesFilter']
    agentId: Union[_str, 'types.StringWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    description: Union[_str, 'types.StringWithAggregatesFilter']
    conversationId: Union[_str, 'types.StringWithAggregatesFilter']
    createdAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    updatedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    deleted: Union[_bool, 'types.BooleanWithAggregatesFilter']
    deletedAt: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['AgentTaskScalarWhereWithAggregatesInput']
    OR: List['AgentTaskScalarWhereWithAggregatesInput']
    NOT: List['AgentTaskScalarWhereWithAggregatesInput']



class AgentTaskGroupByOutput(TypedDict, total=False):
    id: _str
    agentId: _str
    name: _str
    description: _str
    conversationId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime
    _sum: 'AgentTaskSumAggregateOutput'
    _avg: 'AgentTaskAvgAggregateOutput'
    _min: 'AgentTaskMinAggregateOutput'
    _max: 'AgentTaskMaxAggregateOutput'
    _count: 'AgentTaskCountAggregateOutput'


class AgentTaskAvgAggregateOutput(TypedDict, total=False):
    """AgentTask output for aggregating averages"""


class AgentTaskSumAggregateOutput(TypedDict, total=False):
    """AgentTask output for aggregating sums"""


class AgentTaskScalarAggregateOutput(TypedDict, total=False):
    """AgentTask output including scalar fields"""
    id: _str
    agentId: _str
    name: _str
    description: _str
    conversationId: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deleted: _bool
    deletedAt: datetime.datetime


AgentTaskMinAggregateOutput = AgentTaskScalarAggregateOutput
AgentTaskMaxAggregateOutput = AgentTaskScalarAggregateOutput


class AgentTaskMaxAggregateInput(TypedDict, total=False):
    """AgentTask input for aggregating by max"""
    id: bool
    agentId: bool
    name: bool
    description: bool
    conversationId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class AgentTaskMinAggregateInput(TypedDict, total=False):
    """AgentTask input for aggregating by min"""
    id: bool
    agentId: bool
    name: bool
    description: bool
    conversationId: bool
    createdAt: bool
    updatedAt: bool
    deleted: bool
    deletedAt: bool


class AgentTaskNumberAggregateInput(TypedDict, total=False):
    """AgentTask input for aggregating numbers"""


AgentTaskAvgAggregateInput = AgentTaskNumberAggregateInput
AgentTaskSumAggregateInput = AgentTaskNumberAggregateInput


AgentTaskCountAggregateInput = TypedDict(
    'AgentTaskCountAggregateInput',
    {
        'id': bool,
        'agentId': bool,
        'name': bool,
        'description': bool,
        'conversationId': bool,
        'createdAt': bool,
        'updatedAt': bool,
        'deleted': bool,
        'deletedAt': bool,
        '_all': bool,
    },
    total=False,
)

AgentTaskCountAggregateOutput = TypedDict(
    'AgentTaskCountAggregateOutput',
    {
        'id': int,
        'agentId': int,
        'name': int,
        'description': int,
        'conversationId': int,
        'createdAt': int,
        'updatedAt': int,
        'deleted': int,
        'deletedAt': int,
        '_all': int,
    },
    total=False,
)


AgentTaskKeys = Literal[
    'id',
    'agentId',
    'agent',
    'name',
    'description',
    'conversationId',
    'conversation',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
AgentTaskScalarFieldKeys = Literal[
    'id',
    'agentId',
    'name',
    'description',
    'conversationId',
    'createdAt',
    'updatedAt',
    'deleted',
    'deletedAt',
]
AgentTaskScalarFieldKeysT = TypeVar('AgentTaskScalarFieldKeysT', bound=AgentTaskScalarFieldKeys)

AgentTaskRelationalFieldKeys = Literal[
        'agent',
        'conversation',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields